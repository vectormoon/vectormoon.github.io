<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>围城</title>
    <link href="/2021/01/22/WeiCheng/"/>
    <url>/2021/01/22/WeiCheng/</url>
    
    <content type="html"><![CDATA[<h1 id="围城——方鸿渐与四个女人的故事"><a href="#围城——方鸿渐与四个女人的故事" class="headerlink" title="围城——方鸿渐与四个女人的故事"></a>围城——方鸿渐与四个女人的故事</h1><p>​        书中褚慎明提到一句英国古话：“结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟献给出去。”苏文纨随后补充道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡，城外的人想冲进去，城里的人想逃出去。”作者钱锺书借褚慎明和苏文纨之口说出来全书的基调。</p><p>​        方鸿渐作为主角自然也没有逃脱出这个框架，每次都不断地渴望冲出围城，但是每次都会无意中又落入另外一座围城。不断地进进出出，不断地重复着。</p><p>​        从国内留学到澳洲，满是期待的走进“围城”，再乘坐邮轮走出这个“围城”；到上海失业，爱情碰壁结果又走进了新的“围城”；方鸿渐想通过到国立三闾大学开始自己新的生活，来逃离“围城”，在国立三闾大学的明争暗斗让他明白他不过又陷入到了一个新的”围城“；期间他与孙柔嘉的可能又让他萌生出逃离”围城“的想法，便以与孙柔嘉结婚为由回到上海；结果到了上海不过又是一个新的”围城“，事业不顺，妻子施压，赵幸楣在电报中提到会在重庆接应方鸿渐，使得方鸿渐再一次想要冲出被家庭事业所束缚的”围城“，结果被妻子阻挠。书中内容到此为止，不过还是可以预见方鸿渐要么一直被困在妻子所营造的“围城”中，要么又闯入到新的“围城”中。</p><p>​        方鸿渐不断进出围城的过程中遇到的人与事是整本书看点之一。从他们身上可以看出当时中国的一部分社会、一部分人的处境、男女之间的形象对比。全书不停的讽刺过分的人情社会、教育界的迂腐、上层社会的腐败。</p><p>​        方鸿渐与四个女人之间的故事可以算作是书中的主线，发生的一切的一切都是因为她们而起。从被鲍小姐甩掉，转而向苏文纨亲近，通过苏文纨之手认识到唐晓芙，优柔寡断的吻了苏文纨又把苏文纨甩掉，苏文纨把方鸿渐的事情都抖落出来讲给唐晓芙听，唐晓芙与方鸿渐的决裂导致一起去到国立三闾大学，又与孙柔嘉结婚回到上海一系列。这四个女人突出了方鸿渐矛盾的性格也驱动着故事的发展。</p><p>​        这四位女性分别是四种类型各具特点。</p><p>​        鲍小姐作为一个留洋的女学生，书中写道：她只穿绯霞色抹胸，海蓝色贴肉短裤，镂空白皮鞋里露出涂红的指甲。在热带热天，也许是最合适的装束，船上有一两个外国女人就这样打扮。可是苏小姐觉得鲍小姐赤身露背，伤害及中国国体。鲍小姐可以说是西方纵欲主义、享乐主义、自由主义的集成。逢场作戏，善于勾搭男人，不将身心投入到感情中，可以做到说走就走，就如杨绛评价鲍鱼之肆是臭的，所以那位小姐姓鲍，鲍小姐与方鸿渐途中遇到的苏州寡妇和王美玉无异。</p><p>​        苏文纨与鲍小姐同为留洋的女学生，但是两人完全不一样。苏文纨保持着中国国体，但是实际上她的身上又少了点中国闺秀式的温柔，更多的是一种自负、卖弄风气与盛气凌人的习气。书中做的一切都掩饰不住苏文纨的做作、嫉妒和算计。脚踏三只船，喜欢享受男人为他吃醋众星捧月的虚荣，对待方鸿渐更是步步紧逼，最后更是酿成了悲剧。结婚前后整个人又发生了变化，在婚前更多的是一种高傲，自诩女诗人。在婚后又转向香港代购来赚钱。女诗人的头衔又与方鸿渐的博士学位一样，已经随着岁月消逝到远方。不过都是做做样子罢了。</p><p>​        唐晓芙作为一个从未见世面单纯幼稚的女孩子，对待苏文纨气急败坏的流言蜚语没有沉得住气。对于可以原谅的错误，用尽一切气力不留余地的打击方鸿渐的自尊心，方鸿渐在暴雨中的伤心沉默，更是导致了方鸿渐在那之后性情上微妙的变化，怕别人揭穿自己虚假的博士学位，不想让别人觉得自己无能。唐晓芙和方鸿渐互相爱恋，但是却没能走到一起。这其中的原因就是唐晓芙和苏文纨之间的不同，在苏文纨看到报纸上刊登的新闻之后，选择庇护方鸿渐，而唐晓芙作为一个单纯女孩在被苏文纨添油加醋的情况下，做出了糊涂的决定。从书中唐晓芙将书信都送回给方鸿渐这一点也可以看出，唐晓芙是一个洒脱、直爽的女生。</p><p>​        杨绛对孙晓嘉的评价是：她受过高等教育，没什么特长，可也不笨；不是美人，可也不丑；没什么兴趣，却有自己的主张。方鸿渐“兴趣很广，毫无心得“；她是毫无兴趣而很有打算。她的天地极小，只局限于”围城“内外。她所享的自由也有限，能从城外挤入城里，又从城外挤出城外。她最大的成功是嫁了一个方鸿渐，最大的失败也是嫁了一个方鸿渐。孙晓嘉是一个精明能干的小妇人，她性格中多疑、喜嫉、专横、自私是当时中国妇女为了应对一辈子陷入家庭纠纷与苦难所造就的。孙晓嘉是一个很聪明的女人，她先是通过引诱方鸿渐结婚之后又想将方鸿渐征服。想持家更想管着自己丈夫。婚前婚后与苏文纨一样判若两人。</p><p>​        看完整本书之后，对于方鸿渐的选择完全不出意外，在自己海归自尊心极强的时候，自尊心完全被唐晓芙粉碎。钱锺书对国立三闾大学的描写侧重在学校内如何乌烟瘴气，如何拉帮结伙，没有一件好事。在最后也只好落入到孙晓嘉的“围城”中。</p><p>​        钱锺书所写的《围城》可以说是一部旷世奇书。书中提及到的美食、事物有很多都是前所未闻，见识颇多。人物的语言心理上的造诣更达到了巅峰。可以感受人物为人处世的绝妙之处以及书中突出了很多讽刺幽默的描写许多地方都可以不断推敲。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>孤胆枪手</title>
    <link href="/2020/12/09/alien-shooter/"/>
    <url>/2020/12/09/alien-shooter/</url>
    
    <content type="html"><![CDATA[<h2 id="笔者游戏情况"><a href="#笔者游戏情况" class="headerlink" title="笔者游戏情况"></a>笔者游戏情况</h2><ul><li>游戏时长6小时(steam)</li><li>一命通关hard难度</li><li>full version 1.22</li></ul><h2 id="游戏优点"><a href="#游戏优点" class="headerlink" title="游戏优点"></a>游戏优点</h2><ul><li>游戏音乐优秀</li><li>游戏节奏爽快</li></ul><h2 id="游戏缺点"><a href="#游戏缺点" class="headerlink" title="游戏缺点"></a>游戏缺点</h2><ul><li>剧情单薄</li><li>游戏内容少</li><li>成长性系统不完善</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>&emsp;&emsp;十年前第一次玩到这款游戏的时候，当时的我完全觉得它就是一款恐怖游戏，每次玩完教学关之后都被吓的不敢动弹，一直没完整的玩下来过。在去年有幸把这款游戏从头到尾玩了几遍，也算是圆了旧梦。</p><p>&emsp;&emsp;游戏主体就是以无双为核心的射击游戏。剧情简单老套，实验室实验失控主角只身一人闯入失控实验室拯救世界。</p><p>&emsp;&emsp;游戏优点突出。游戏音乐非常优秀，在昏暗场景下的音乐非常压抑，在主角解密完成之后，外星人蜂拥而至，即刻转换到激情昂扬的bgm更是让人血脉偾张。再加上游戏节奏非常爽快，与bgm的搭配，是本作最大的卖点。</p><p>&emsp;&emsp;我上面提到的：圆了我的旧梦，但是重温旧梦就是破坏旧梦。孤胆枪手的缺点也非常明显。首先第一点就是剧情方面，剧情过于单薄，整个剧情演出仅由数十秒其余全靠脑补，结尾的悬念设置的很好，如果关卡与关卡之间加上过场剧情会好上不少；第二点也是最重要的一点就是成长系统的不完善，游戏仅提供九种武器和四种基础属性补正，导致游戏最后一关明显火力不足，显得游戏节奏异常拖沓，玩完最后一关前期爽快好感全无；第三点就是游戏内容过少，整个游戏玩完一周目差不多耗时五十分钟。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;孤胆枪手就算是放到现在也是一种极为少见的游戏类型，采用45度上帝视角射击，类似无双的玩法。不过它的“少见”也验证了这类游戏不可行，它只能作为零几年那个时代的产物，作为曾经那个时代的电子游戏敲门砖。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>QPushButton类的使用</title>
    <link href="/2020/12/01/QPushButton/"/>
    <url>/2020/12/01/QPushButton/</url>
    
    <content type="html"><![CDATA[<h1 id="QPushButton的使用"><a href="#QPushButton的使用" class="headerlink" title="QPushButton的使用"></a>QPushButton的使用</h1><h2 id="QPushButton类定义"><a href="#QPushButton类定义" class="headerlink" title="QPushButton类定义"></a>QPushButton类定义</h2><p><img src="C:\Users\51402\blog\source\img\blog_contents\QT\QPushButton_1.png" alt="QPushButton_1"></p><h2 id="创建按钮"><a href="#创建按钮" class="headerlink" title="创建按钮"></a>创建按钮</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><pre><code class="hljs c++"><span class="hljs-comment">//创建按钮</span>   QPushButton *btn1 = <span class="hljs-keyword">new</span> QPushButton;   <span class="hljs-comment">//btn-&gt;show();//show以顶层方式弹出窗口控件</span>   <span class="hljs-comment">//使btn对象依附于myWidget窗口</span>   btn1-&gt;setParent(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">//显示文本</span>   btn1-&gt;setText(<span class="hljs-string">&quot;btn1&quot;</span>);</code></pre><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><pre><code class="hljs c++"><span class="hljs-comment">//等价于上面的方法 有一个弊端是按照控件的大小创建窗口</span>   QPushButton *btn2 = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">&quot;btn2&quot;</span>, <span class="hljs-keyword">this</span>);</code></pre><h2 id="移动、重置窗口大小"><a href="#移动、重置窗口大小" class="headerlink" title="移动、重置窗口大小"></a>移动、重置窗口大小</h2><h3 id="窗口坐标体系"><a href="#窗口坐标体系" class="headerlink" title="窗口坐标体系"></a>窗口坐标体系</h3><p>以左上角为原点(0,0)，X自左到右，Y自上到下</p><h3 id="移动按钮位置"><a href="#移动按钮位置" class="headerlink" title="移动按钮位置"></a>移动按钮位置</h3><pre><code class="hljs c++"><span class="hljs-comment">//移动btn按钮</span>btn2-&gt;move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);</code></pre><h3 id="重置窗口、按钮大小"><a href="#重置窗口、按钮大小" class="headerlink" title="重置窗口、按钮大小"></a>重置窗口、按钮大小</h3><pre><code class="hljs c++"><span class="hljs-comment">//重置窗口大小</span>resize(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);<span class="hljs-comment">//重置按钮大小</span>btn2-&gt;resize(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>);</code></pre><h3 id="设置窗口大小（大小无法被调整）"><a href="#设置窗口大小（大小无法被调整）" class="headerlink" title="设置窗口大小（大小无法被调整）"></a>设置窗口大小（大小无法被调整）</h3><pre><code class="hljs c++"><span class="hljs-comment">//设置固定窗口大小</span>setFixedSize(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);</code></pre><h3 id="设置窗口标题"><a href="#设置窗口标题" class="headerlink" title="设置窗口标题"></a>设置窗口标题</h3><pre><code class="hljs c++"><span class="hljs-comment">//设置窗口标题</span>setWindowTitle(<span class="hljs-string">&quot;窗口&quot;</span>);</code></pre><h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><p>创建的对象，如果是派生类不用管理其释放操作，该对象会加入到对象树，递归的释放</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>QT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>qt程序创建及模板代码分析</title>
    <link href="/2020/11/29/Introduction-to-qt/"/>
    <url>/2020/11/29/Introduction-to-qt/</url>
    
    <content type="html"><![CDATA[<p>qt ver 5.14.2</p><h1 id="qt-Creator创建程序"><a href="#qt-Creator创建程序" class="headerlink" title="qt Creator创建程序"></a>qt Creator创建程序</h1><h2 id="Build-System"><a href="#Build-System" class="headerlink" title="Build System"></a>Build System</h2><ul><li>Qbs市场占有率低，将被弃用</li><li>qmake更轻量级</li><li>cmake功能强大</li></ul><p>不繁琐的小程序用qmake，大工程文件用cmake更好</p><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Base class有三个选项：</p><ul><li>QMainWindow</li><li>QWidget</li><li>QDialog</li></ul><p>QMainWindow和QDialog是QWidget的子类。QWidget创建出来只有一个空白界面；QMainWindow在QWidget基础上多了菜单栏，工具栏和状态栏；QDialog对应对话框。</p><p>Generate form选项可以通过拖拽完成界面的设计</p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>Translation File功能显见</p><h2 id="Kits"><a href="#Kits" class="headerlink" title="Kits"></a>Kits</h2><p>版本套件选择，例如：Desktop对应.exe开发；UWP对应windows通用平台开发；</p><h1 id="qt程序组成"><a href="#qt程序组成" class="headerlink" title="qt程序组成"></a>qt程序组成</h1><blockquote><p> main.cpp</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mywidget.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt; // 包含一个应用程序类的头文件</span></span><span class="hljs-comment">//main程序入口；argc命令行变量的数量；argv命令行变量的数组</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;    <span class="hljs-comment">//a应用程序对象，在Qt中，应用程序对象有且仅有一个</span>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    <span class="hljs-comment">//窗口对象，myWidget父类-&gt;QWidget</span>    myWidget w;    <span class="hljs-comment">//窗口对象 默认不会显示，必须要调用show方法才能显示窗口</span>    w.show();        <span class="hljs-comment">//让应用程序对象进入消息循环机制，窗口不会一闪而过</span>    <span class="hljs-keyword">return</span> a.exec();&#125;</code></pre><blockquote><p>.pro文件</p></blockquote><pre><code class="hljs c++">QT       += core gui <span class="hljs-comment">//QT包含模块</span>greaterThan(QT_MAJOR_VERSION, <span class="hljs-number">4</span>): QT += widgets <span class="hljs-comment">//版本号大于4所额外包含模块</span>CONFIG += c++<span class="hljs-number">11</span># The following define makes your compiler emit warnings <span class="hljs-keyword">if</span> you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile <span class="hljs-keyword">if</span> it uses deprecated APIs.# In order to <span class="hljs-keyword">do</span> so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=<span class="hljs-number">0x060000</span>    # disables all the APIs deprecated before Qt <span class="hljs-number">6.0</span><span class="hljs-number">.0</span>SOURCES += \<span class="hljs-comment">//源文件</span>    main.cpp \    mywidget.cppHEADERS += \<span class="hljs-comment">//头文件</span>    mywidget.hFORMS += \    mywidget.ui# Default rules <span class="hljs-keyword">for</span> deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin<span class="hljs-keyword">else</span>: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target</code></pre><blockquote><p>mywidget.h</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MYWIDGET_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MYWIDGET_H</span><span class="hljs-comment">//防止被多次include，文件只会被编译一次和pragma once等效</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;//窗口类QWidget头文件</span></span>QT_BEGIN_NAMESPACE<span class="hljs-keyword">namespace</span> Ui &#123; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myWidget</span>;</span> &#125;QT_END_NAMESPACE<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget&#123;    Q_OBJECT <span class="hljs-comment">//Q_OBJECT是一个宏，允许类中使用信号和槽的机制</span><span class="hljs-keyword">public</span>:    myWidget(QWidget *parent = <span class="hljs-literal">nullptr</span>);    ~myWidget();<span class="hljs-keyword">private</span>:    Ui::myWidget *ui;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// MYWIDGET_H</span></span></code></pre><blockquote><p>mywidget.cpp</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mywidget.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mywidget.h&quot;</span></span><span class="hljs-comment">//命名规范</span><span class="hljs-comment">//类名 首字母大写，单词和单词之间首字母大写</span><span class="hljs-comment">//函数名 变量名称 首字母小写，单词和单词之间首字母大写</span><span class="hljs-comment">//快捷键</span><span class="hljs-comment">//注释 ctrl + /</span><span class="hljs-comment">//运行 ctrl + r</span><span class="hljs-comment">//编译 ctrl + b</span><span class="hljs-comment">//字体缩放 ctrl + 鼠标滚轮</span><span class="hljs-comment">//自动对齐 ctrl + i</span>myWidget::myWidget(QWidget *parent)    : QWidget(parent)    , ui(<span class="hljs-keyword">new</span> Ui::myWidget)&#123;    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);&#125;myWidget::~myWidget()&#123;    <span class="hljs-keyword">delete</span> ui;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>QT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL更新功能</title>
    <link href="/2020/10/27/SQL-update/"/>
    <url>/2020/10/27/SQL-update/</url>
    
    <content type="html"><![CDATA[<h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name[<span class="hljs-keyword">WHERE</span> search_condition];</code></pre><p>在table_name表中删除符合条件search_condition的元组</p><ul><li>在忽略WHERE子句的情况下，删除表table_name中的所有元组</li></ul><p><strong>例</strong>：删除计算机系（CS）全体学生的选课记录</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span><span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>sno <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span>sno<span class="hljs-keyword">FROM</span> S<span class="hljs-keyword">WHERE</span>sd=<span class="hljs-string">&#x27;CS&#x27;</span>)</code></pre><h2 id="元组插入功能"><a href="#元组插入功能" class="headerlink" title="元组插入功能"></a>元组插入功能</h2><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span><span class="hljs-keyword">INTO</span>tabname [(colname &#123;, colname ...&#125;)]<span class="hljs-keyword">VALUES</span>(expr|<span class="hljs-literal">NULL</span> &#123;, expr|<span class="hljs-literal">NULL</span> ...&#125;) | subquery;</code></pre><p><strong>例</strong>：插入计算机系（CS）学生选修数据库（Database）课的选课记录</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SC(sno,cno)<span class="hljs-keyword">SELECT</span>sno, cno<span class="hljs-keyword">FROM</span> S, C<span class="hljs-keyword">WHERE</span>sd=<span class="hljs-string">&#x27;CS&#x27;</span> <span class="hljs-keyword">and</span> cn=<span class="hljs-string">&#x27;Database&#x27;</span>;</code></pre><h2 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h2><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span>table_name<span class="hljs-keyword">SET</span>colname=expr|<span class="hljs-literal">NULL</span>|subquery,...[<span class="hljs-keyword">WHERE</span> search_condition]</code></pre><p>修改指定基表table_name中满足的WHERE条件的元组</p><ul><li>用SET子句中的赋值语句修改相关元组对应的属性</li></ul><p><strong>例</strong>：将计算机系学生的成绩全置零</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span>SC<span class="hljs-keyword">SET</span>G=<span class="hljs-number">0</span><span class="hljs-keyword">WHERE</span>sno <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> sno<span class="hljs-keyword">FROM</span>S<span class="hljs-keyword">WHERE</span>sd=<span class="hljs-string">&#x27;CS&#x27;</span>);</code></pre><p><strong>例</strong>：将数学系学生的年龄均加1岁</p><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span>S<span class="hljs-keyword">SET</span>sa=sa+<span class="hljs-number">1</span><span class="hljs-keyword">WHERE</span>sd=<span class="hljs-string">&#x27;math&#x27;</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>饮馔部_蔬食第一</title>
    <link href="/2020/10/25/xianqingouji-yinzhuanbu-shushi/"/>
    <url>/2020/10/25/xianqingouji-yinzhuanbu-shushi/</url>
    
    <content type="html"><![CDATA[<h2 id="蔬食"><a href="#蔬食" class="headerlink" title="蔬食"></a>蔬食</h2><h4 id="小序"><a href="#小序" class="headerlink" title="小序"></a>小序</h4><blockquote><p>吾观人之一身，眼耳鼻舌，手足躯骸，件件都不可少。其尽可不设而必欲赋之，遂为万古生人之累者，独是口腹二物。</p></blockquote><p>​        口腹二物会导致人的欲望无穷无尽。</p><blockquote><p>声音之道，丝不如竹，竹不如肉，为其渐进自然。吾谓饮食之道，脍不如肉，肉不如蔬，亦以其渐进自然也。吾辑《饮馔》一卷，后肉食而首蔬菜，一为崇俭，一为复古。</p></blockquote><p>​        饮馔部从蔬食、谷食、肉食的顺序编排，这个顺序也是李渔对各食材喜爱程度的缩影。全文的基调是越贴近大自然的食物越鲜美。</p><p>​        <strong>脍：</strong>细切的肉食</p><h4 id="笋"><a href="#笋" class="headerlink" title="笋"></a>笋</h4><blockquote><p>论蔬食之美者，曰清，曰洁，曰芳馥，曰松脆而已矣。不知其至美所在，能居肉食之上者，忝在一字之鲜。《记》曰：“甘受和，白受采”。</p></blockquote><p>​        甘受和，白受采。忠信之人,可以学礼。：美味的食物能和众味，白色容易被染上其他色彩。甘为众味之本，不偏主一味，故得受五味之和；白是五色之本，不偏主一色，故得受五色之采。同样忠信之人，可以接受学习各种礼法。古人以此喻人素质好。</p><blockquote><p>食笋之法多端，不能悉纪，请以两言概之，曰：“素宜白水，荤用肥猪。”茹斋者食笋，若以他物伴之，香油和之，则陈味夺鲜，而笋之真趣没矣。白煮俟熟，略加酱油。从来至美之物，皆利于孤行，此类是也。以之伴荤，则牛羊鸡鸭等物，皆非所宜，独宜于豕，又独宜于肥。肥非欲其腻也，肉之肥者能甘，甘味入笋，则不见其甘，但觉其鲜之至也。烹之既熟，肥肉尽当去之，即汁亦不宜多存，存其而益以清汤。调和之物，惟醋与酒。此制荤笋之大凡也。笋之为物，不止孤行并用，各见其美，凡食物中无论荤素，皆当用作调和。</p></blockquote><p>​        俟：&lt;动&gt;等待</p><p>​        留白补图</p><blockquote><p>菜中之笋，与药中之甘草，同是必需之物，有此则诸味皆鲜，但不当用其渣滓，而用其精液。疱人之善治具者，凡是焯笋之汤，悉留不去，每作一馔，必以和之。食者但知他物之鲜，而不知有所以鲜之者在也。</p></blockquote><p>​    </p><h4 id="蕈"><a href="#蕈" class="headerlink" title="蕈"></a>蕈</h4><blockquote><p>举至鲜至美之物，于笋之外，其惟蕈乎？</p></blockquote><p>​        蕈(xùn)：&lt;名&gt;真菌的一类，指蘑菇</p><blockquote><p>此物素食固佳，伴以少许荤食尤佳。盖蕈之清香有限，而汁之鲜味无穷。</p></blockquote><p>​        留白补图</p><h4 id="莼"><a href="#莼" class="headerlink" title="莼"></a>莼</h4><blockquote><p>陆之蕈，木之莼，皆清虚妙物也。予尝以二物作羹，和以蟹之黄，鱼之肋，名曰“四美羹”。座客食而甘之，曰：“今而后，天下箸处矣！”</p></blockquote><p>​        莼(chún)：&lt;名&gt;一种水草，嫩叶可食</p><p>​        留白补图</p><h4 id="菜"><a href="#菜" class="headerlink" title="菜"></a>菜</h4><blockquote><p>世人制菜之法，可称百怪千奇，自新鲜以至于腌糟酱醋，无一不曲尽奇能，务求至美，独于起根发轫之事缺焉不讲，予甚惑之。其事维何？有八字决云：“摘之务鲜，洗之务净。”务鲜之论，已悉前篇。</p></blockquote><p>​        轫：&lt;名&gt;刹住车轮的木头</p><p>​        发轫：拿掉支住车轮的木头，使车前进，比喻新事物或某种局面开始出现</p><blockquote><p>菜类甚多，其杰出者则数黄芽。此菜萃于京师，而产于安肃，谓之“安肃菜”，此第一品也。每株大者可数斤，食之可忘肉味。不得已而思其次，其惟白下之水芹乎！予子移居白门，每食菜、食葡萄，辄思都门；食笋，食鸡头，辄思武陵。<strong>物之美者，犹令人每食不忘，况为适馆授餐之人乎？</strong></p></blockquote><p>​        黄芽：指黄芽菜，白菜的别称</p><p>​        白门：建康宣阳门的俗称，南京的别称</p><p>​        鸡头：芡实，睡莲植物的成熟干燥果实，一种中药</p><blockquote><p>菜有色相最奇，而为《本草》、《食物志》诸书之所不载者，则西秦所产之头发菜是也。予为秦客。一日脂车将发，见炕上有物，俨然乱发一卷，谬谓婢子栉发所遗，将欲委之而去。婢子曰：“不然，群公所饷之物也。”询之土人，知为头发菜。<strong>浸以滚水，伴以姜醋，其可口倍于藕丝、鹿角等菜。</strong>“携归饷客，无不奇之，谓珍错中所未见。此物产于河西，为值甚贱，凡适秦者，皆争购异物，因其贱也而忽之，故此物不至通都，见着绝少。由是观之，四方贱物之中，其可贵者不知凡几，焉得人人物色之？发菜之得至江南，亦千载一时之至幸也。</p></blockquote><p>​        脂：&lt;动&gt;用脂膏涂车轴，使其润滑</p><p>​        栉(zhì)：&lt;动&gt;梳理头发</p><p>​        不过发菜现在也吃不到，现在能买到所谓的发菜应该是头发菜罢</p><p>​        留白补图</p><h4 id="瓜、茄、瓠、芋、山药"><a href="#瓜、茄、瓠、芋、山药" class="headerlink" title="瓜、茄、瓠、芋、山药"></a>瓜、茄、瓠、芋、山药</h4><blockquote><p>瓜、茄、瓠、芋诸物，菜之结而为实者。实则不止当菜，兼作饭矣。增一簋菜，可省数合粮者，诸物是也。一事两用，何俭如之？贫家购此，同于籴栗。</p></blockquote><p>​        瓠(hù)：瓠瓜类似于西葫芦</p><p>​        簋(guǐ)：&lt;名&gt;古代盛食物的圆形器具</p><p>​        籴(dí)：&lt;动&gt;买进谷米，跟“粜”相对</p><blockquote><p>但食之各有其法：煮冬瓜、丝瓜忌太生；煮王瓜、甜瓜忌太熟；煮茄、瓠利用酱醋，而不宜于盐；煮芋不可无物伴之，盖芋之本身无味，借他物以成其味者也；山药则孤行并用，无所不宜，并油盐酱醋不设，亦能自呈其美，乃蔬食中之通材也。</p></blockquote><p>​        王瓜：黄瓜</p><h4 id="葱、蒜、韭"><a href="#葱、蒜、韭" class="headerlink" title="葱、蒜、韭"></a>葱、蒜、韭</h4><blockquote><p>葱、蒜、韭三物，菜味之至重者也。菜能芬人齿颊者，香椿头是也；菜能秽人齿颊及肠胃者，葱、蒜、韭是也。椿头明知其香，而食者颇少，葱、蒜、韭尽识其臭，而嗜之者众，其故何欤？以椿头之味，虽香而淡，不若葱、蒜、韭之气甚而浓。浓则为时所争尚，甘受其秽而不辞；淡则为世所共遗，自荐其香而弗受。吾于饮食一道，悟善身处事之难。一生绝三物不食，亦未尝多事香椿，殆所谓“夷、惠之间”者乎？</p></blockquote><p>​        为人处世之难就是做人既不能像葱蒜韭味重讨人嫌，也不能像香椿一样容易被人淡忘</p><p>​        夷、惠之间：伯夷、柳下惠；指有操守的人</p><blockquote><p>予待三物有差。蒜则永禁弗食；葱虽弗食，然亦听作调和；韭则禁其终而不禁其始，芽之初发，非特不臭，且具清香，是其孩提之心之未变也。</p></blockquote><h4 id="萝卜"><a href="#萝卜" class="headerlink" title="萝卜"></a>萝卜</h4><blockquote><p>生萝卜切丝作小菜，伴以醋及他物，用之下粥最宜</p></blockquote><p>​        留白补图</p><blockquote><p>但恨其食后打嗳，嗳必秽气。予尝受此厄于人，知人之厌我，亦若是也，故亦欲绝而弗食。然见此物大异葱蒜，生则臭，熟则不臭，是与初见似小人，而卒为君子者等也。虽有微过，亦当恕之，仍食勿禁。</p></blockquote><p>​        可能这就是古人的真香罢                </p><h4 id="芥辣汁"><a href="#芥辣汁" class="headerlink" title="芥辣汁"></a>芥辣汁</h4><blockquote><p>菜有具姜、桂之性者乎？曰：有，辣芥是也。制辣汁之芥子，陈者绝佳。所谓愈老愈辣是也。以此拌物，无物不佳。食之者如遇正人，如闻谠论，困者为之起倦，闷者以之豁襟，食中之爽味也。予每食必备，窃比于夫子之不撤姜也。</p></blockquote><p>​        不撤姜：《论语》不撤姜食，不多食；,</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>闲情偶寄</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL数据操纵</title>
    <link href="/2020/10/24/SQL-search/"/>
    <url>/2020/10/24/SQL-search/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL的基本查询功能"><a href="#SQL的基本查询功能" class="headerlink" title="SQL的基本查询功能"></a>SQL的基本查询功能</h1><h2 id="映像语句"><a href="#映像语句" class="headerlink" title="映像语句"></a>映像语句</h2><ul><li>目标子句：SELECT *|colname {, colname…}</li><li>范围子句：FROM tablename {, tablename…}</li><li>条件子句：[WHERE search_condition]</li><li>分组子句：[GROUP BY colname {, colname…}</li><li>分组查询子句：[HAVING group_condition]]</li><li>排序输出子句：[ORDER BY colname [ASC|DESC] {, colname[ASC|DESC]…}]</li></ul><p><strong>上述子句执行顺序</strong>：FROM(选表)-&gt;WHERE(条件选择)-&gt;GROUP BY(分组)-&gt;HAVING(条件选择)-&gt;SELECT(投影)-&gt;ORDER BY(排序)</p><h2 id="目标子句"><a href="#目标子句" class="headerlink" title="目标子句"></a>目标子句</h2><p>SELECT子句相当于投影运行，有如下构造方式：</p><ul><li><p>给出结果属性的属性名</p><ul><li><p>通过‘表名.属性名’的方式来表明是哪一张表中的属性</p></li><li><p>结果属性的重命名，比如：</p>  <pre><code class="hljs sql">&lt;column_expression&gt; AS &lt;colname&gt;</code></pre></li></ul></li><li><p>可用’*’来代替表中所有属性</p></li><li>可用保留字’distinct’来消除结果中的重复元组</li></ul><h2 id="范围子句"><a href="#范围子句" class="headerlink" title="范围子句"></a>范围子句</h2><p>FROM指定操作对象</p><p>可以在FROM子句中对一个关系重新命名，如：</p><pre><code class="hljs sql">&lt;table_name&gt; &lt;alias_name&gt;</code></pre><ul><li>主要用于关系自身的联接运算</li></ul><p><strong>SELECT子句</strong>和<strong>FROM子句</strong>是一条映像语句中必不可少的两个组成部分</p><h2 id="条件子句"><a href="#条件子句" class="headerlink" title="条件子句"></a>条件子句</h2><p>WHERE是映像语句中的可选部分，用于定义查询条件。包括<strong>单个关系的元组选择条件</strong>以及<strong>关系与关系之间的联接条件</strong>都需要WHERE子句的逻辑表达式表示出来，比如说：</p><ul><li>FROM子句中给出的关系只能表明此次查询需要这些关系，它们是通过<strong>笛卡尔积</strong>运算合并起来的</li><li>如果需要执行他们之间$\theta$<strong>联接</strong>或<strong>自然联接</strong>运算，则需要在WHERE子句中显式地给出他们的联接条件</li></ul><h2 id="常用谓词"><a href="#常用谓词" class="headerlink" title="常用谓词"></a>常用谓词</h2><p>除常用的算术比较运算符外，SQL还提供了若干比较谓词，以增加查询语句的表达能力：</p><ul><li>DISTINCT（去重）</li><li>BETWEEN … AND … （查询一个区间）</li><li>NOT BETWEEN … AND …</li><li>LIKE（见下）</li><li>NOT LIKE</li><li>IS NULL（为空）</li><li>IS NOT NULL</li></ul><p>DISTINCT仅用于SELECT子句中，其他谓词一般用于WHERE子句中，用于构造查询条件</p><h4 id="LIKE谓词的使用方法"><a href="#LIKE谓词的使用方法" class="headerlink" title="LIKE谓词的使用方法"></a>LIKE谓词的使用方法</h4><pre><code class="hljs sql">column [NOT] LIKE val1 [ESCAPE val2]</code></pre><ul><li>模板（pattern）：val1<ul><li>下划线（_）：可以匹配任意一个字符</li><li>百分号（%）：可以匹配任意一个字符串（包括长度为0的空字符串）</li><li>其他字符：只能匹配其自身</li></ul></li><li>转义指示字符：val2<ul><li>紧跟在转义指示字符val2之后的”_”或”%”(包括转义字符本身)不再是通配符，而是其自身</li></ul></li></ul><p><strong>例</strong>：查询姓名为A开头，且第三个字符必为P的学生的姓名和系别</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sn,sd<span class="hljs-keyword">FROM</span>S<span class="hljs-keyword">WHERE</span>sn <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;A_P%&#x27;</span>;</code></pre><p>查询在课程名中含有下划线（_）的课程的课程名</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cno<span class="hljs-keyword">FROM</span> C<span class="hljs-keyword">WHERE</span> cn <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%A_%&#x27;</span> ESCAPE <span class="hljs-string">&#x27;A&#x27;</span>;</code></pre><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>在WHERE子句中，可以使用NOT、AND与OR这三个逻辑运算符构造出复杂的查询条件</p><h2 id="简单连接"><a href="#简单连接" class="headerlink" title="简单连接"></a>简单连接</h2><p>在WHERE子句中，通过两个属性之间的相等比较实现表与表之间的连接</p><p><strong>例</strong>：查询修读课程号为DATABASE的所有学生的姓名</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>S.sn<span class="hljs-keyword">FROM</span>S,SC,C<span class="hljs-keyword">WHERE</span>S.sno=SC.sno <span class="hljs-keyword">AND</span> SC.cno=C.cno <span class="hljs-keyword">AND</span> C.cn=<span class="hljs-string">&#x27;DATABASE&#x27;</span>;</code></pre><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>在查询中，有时需要对相同的表进行连接。为了区分两张相同的表，必须在FROM子句中至少对其中之一进行换名，以区分开这两张表</p><p><strong>例</strong>：查询至少修读学号为S5的学生所修读的一门课程的学生的学号</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SC1.sno<span class="hljs-keyword">FROM</span>SC SC1, SC SC2<span class="hljs-keyword">WHERE</span>SC1.cno=SC2.cno <span class="hljs-keyword">AND</span> SC2.sno = <span class="hljs-string">&#x27;s5&#x27;</span>;</code></pre><h2 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h2><p>有时，需要查询结果按照某种顺序显示，此时需要加一个排序子句ORDER BY，形式如下：</p><pre><code class="hljs sql">ORDER BY &lt;colname&gt; [ASC|DESC] &#123;, ...&#125;</code></pre><p>其中：</p><ul><li><colname>给出需要排序的列的列名</li><li>ASC|DESC则给出排序升序或降序参数，缺省值是升序</li></ul><h1 id="分层查询与集合谓词使用"><a href="#分层查询与集合谓词使用" class="headerlink" title="分层查询与集合谓词使用"></a>分层查询与集合谓词使用</h1><ul><li>分层结构指的是一条映像语句的某个子句中嵌入另一条映像语句，被嵌入的映像语句通常称为子查询。如下:</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>...<span class="hljs-keyword">FROM</span>...<span class="hljs-keyword">WHERE</span>...(<span class="hljs-keyword">SELECT</span>...    <span class="hljs-keyword">FROM</span>...    <span class="hljs-keyword">WHERE</span>...);</code></pre><ul><li><p>子查询通常被嵌入WHERE子句中，可使结构清晰</p></li><li><p>由于子查询的查询结果是一个集合，因此需要在WHERE子句中引入集合谓词</p></li><li><p>WHERE子句中的集合谓词主要有：</p><ul><li><p>IN谓词：标量与集合量之间的属于比较</p>  <pre><code class="hljs sql">expr [NOT] IN (subquery)</code></pre></li><li><p>限定比较谓词：标量与集合中元素之间的量化比较</p>  <pre><code class="hljs sql">expr θ ANY|ALL (subquery)</code></pre></li><li><p>EXISTS谓词：是否为空集的判断谓词</p>  <pre><code class="hljs sql">[NOT] EXISTS (subquery)</code></pre></li></ul></li><li><p>嵌套查询的处理顺序</p><ul><li>一般情况下，嵌套查询中的子查询只需要被执行一次，然后利用所获得的中间查询结果来计算外层的查询语句，这样的子查询也被称为<strong>独立子查询</strong>，其处理顺序<strong>由内到外</strong></li><li>在有些情况下，在子查询中调用了外层查询中的表以及元组变量。随着外层元组变量的每一次的取值变化，都需要重新执行子查询以获得相关的中间查询结果，这样的子查询也被称为<strong>相关子查询</strong>，其处理顺序是<strong>由外到内</strong>，直至处理完外层查询表中的所有元组</li></ul></li></ul><h2 id="IN谓词的使用"><a href="#IN谓词的使用" class="headerlink" title="IN谓词的使用"></a>IN谓词的使用</h2><p><strong>例</strong>：查询修读课程名为C1的所有学生的姓名</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><p>独立子查询</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> S.sn<span class="hljs-keyword">FROM</span>S<span class="hljs-keyword">WHERE</span>S.sno <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span>SC.sno<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>SC.cno=<span class="hljs-string">&#x27;c1&#x27;</span>);</code></pre><p>相关子查询</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>S.sn<span class="hljs-keyword">FROM</span>S<span class="hljs-keyword">WHERE</span><span class="hljs-string">&#x27;C1&#x27;</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span>SC.cno<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>SC.sno=S.sno)</code></pre><h2 id="限定比较谓词的使用"><a href="#限定比较谓词的使用" class="headerlink" title="限定比较谓词的使用"></a>限定比较谓词的使用</h2><p>谓词ANY表示子查询结果集合中的某个值，而谓词ALL表示子查询结果集中的所有值。</p><p><strong>例</strong>：查询有学生成绩大于 C1 课程号中所有学生成绩的学生学号</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>sno<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>g &gt; <span class="hljs-keyword">ALL</span> (<span class="hljs-keyword">SELECT</span>g<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>cno=<span class="hljs-string">&#x27;C1&#x27;</span>);</code></pre><p>查询有学生成绩大于等于 C1 课程号中的任何一位学生成绩的学生学号</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>sno<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>g &gt;= <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">SELECT</span>g<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>cno=<span class="hljs-string">&#x27;C1&#x27;</span>);</code></pre><h2 id="谓词CONTAINS的使用"><a href="#谓词CONTAINS的使用" class="headerlink" title="谓词CONTAINS的使用"></a>谓词CONTAINS的使用</h2><p>集合间的关系可以通过WHERE子句中SELECT语句间的包含符CONTAINS实现</p><p><strong>例</strong>：查询至少修读学号为 S4 的学生所修读的所有课程的学生的学号</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sno<span class="hljs-keyword">FROM</span> SC<span class="hljs-keyword">WHERE</span>(    <span class="hljs-keyword">SELECT</span> SCx.cno    <span class="hljs-keyword">FROM</span> SC SCx    <span class="hljs-keyword">WHERE</span> SC.sno = SCx.sno)CONTAINS(<span class="hljs-keyword">SELECT</span> SC.cno     <span class="hljs-keyword">FROM</span> SC.SCy         <span class="hljs-keyword">WHERE</span> SCy.sno = ‘S4’);</code></pre><ul><li>SQL标准中并没有提供CONTAINS操作符</li></ul><h2 id="谓词EXISTS的使用"><a href="#谓词EXISTS的使用" class="headerlink" title="谓词EXISTS的使用"></a>谓词EXISTS的使用</h2><p><strong>例</strong>：查询修读课程号为 C1 的所有学生的姓名</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> S.sn<span class="hljs-keyword">FROM</span> S<span class="hljs-keyword">WHERE</span><span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span> S.sno = SC.sno <span class="hljs-keyword">AND</span> SC.cno = ‘C1’);</code></pre><h1 id="SELECT语句间的运算"><a href="#SELECT语句间的运算" class="headerlink" title="SELECT语句间的运算"></a>SELECT语句间的运算</h1><p>子查询之间的并、交、差运算：</p><ul><li>&lt;子查询1&gt; UNION [ALL] &lt;子查询2&gt;</li><li>&lt;子查询1&gt; INTERSECT [ALL]&lt;子查询2&gt;</li><li>&lt;子查询1&gt; EXCEPT [ALL]&lt;子查询2&gt;</li></ul><p><strong>例</strong>：查询计算机系的学生以及年龄小于 20 岁的学生</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">WHERE</span> sd=<span class="hljs-string">&#x27;CS&#x27;</span>)<span class="hljs-keyword">UNION</span>(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">WHERE</span> sa&lt;<span class="hljs-number">20</span>);</code></pre><h1 id="SQL计算、统计、分类的功能"><a href="#SQL计算、统计、分类的功能" class="headerlink" title="SQL计算、统计、分类的功能"></a>SQL计算、统计、分类的功能</h1><h2 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>参数类型</th><th>结果类型</th><th>说明</th></tr></thead><tbody><tr><td>COUNT</td><td>any(can be *)</td><td>numeric</td><td>count of rows</td></tr><tr><td>SUM</td><td>numeric</td><td>numeric</td><td>sum of argument</td></tr><tr><td>AVG</td><td>numeric</td><td>numeric</td><td>average of argument</td></tr><tr><td>MAX</td><td>char or numeric</td><td>same as argument</td><td>maximum value</td></tr><tr><td>MIN</td><td>char or numeric</td><td>same as argument</td><td>minimum value</td></tr></tbody></table></div><p><strong>上述函数不能在WHERE语句中使用</strong></p><p><strong>例</strong>：给出学号为 S1 学生修读的课程门数</p><p>S(sno,sn,sd,sa)        C(sno,cn,pno)        SC(sno,cno,g)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><span class="hljs-keyword">COUNT</span> (*)<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>sno=<span class="hljs-string">&#x27;S1&#x27;</span></code></pre><p>给出学号为 S7 学生所修读课程的平均成绩</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><span class="hljs-keyword">AVG</span>(G)<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span>sno=<span class="hljs-string">&#x27;S7&#x27;</span></code></pre><p>查询所享受的折扣(discnt)并非最高的客户编号(cid)</p><p>Customers (cid, cname, city, discnt)<br>Agents (aid, aname, city, percent)<br>Products (pid, pname, city, quantity, price)<br>Orders (ordno, month, cid, aid, pid, qty, dollars)</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cid<span class="hljs-keyword">FROM</span> Customers<span class="hljs-keyword">WHERE</span> discnt &lt; <span class="hljs-keyword">ALL</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">max</span>(c2.discnt)<span class="hljs-keyword">FROM</span> Customers c2);</code></pre><p>查询有两个或两个以上的客户订购过的商品的编号</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>p.pid<span class="hljs-keyword">FROM</span>Products p<span class="hljs-keyword">WHERE</span> <span class="hljs-number">2</span> &lt;= <span class="hljs-keyword">ALL</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> cid)<span class="hljs-keyword">FROM</span>orders o<span class="hljs-keyword">WHERE</span>o.pid = p.pid);</code></pre><h2 id="分类功能"><a href="#分类功能" class="headerlink" title="分类功能"></a>分类功能</h2><ul><li>分组查询子句：GROUP BY colname {, colname …}<ul><li>GROUP BY的参数是SELECT的子集</li><li>根据属性colname的取值的不同，将满足WHERE条件的元组划分为不同的集合</li><li>使用GROUP BY子句的目的是可以在SELECT子句中针对不同的元组集合分别进行统计计算，实现分类统计查询</li></ul></li><li>HAVING group_condition<ul><li>根据GROUP BY子句的分组结果，定义分组查询条件</li><li>只有满足条件的元组集合才会被保留下来，用于生成最终的查询结果</li><li>在HAVING子句中给出的条件是定义在分组后元组集合上</li></ul></li></ul><p><strong>IBM的例子</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DEP, JOB, <span class="hljs-keyword">AVG</span>(SAL)<span class="hljs-keyword">FROM</span>EMPL<span class="hljs-keyword">WHERE</span>JOB &lt;&gt;<span class="hljs-string">&#x27;M&#x27;</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> DEP,JOB<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">AVG</span>(SAL) &gt; <span class="hljs-number">28000</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">AVG</span>(SAL) <span class="hljs-keyword">DESC</span></code></pre><p><img src="C:\Users\51402\blog\source\img\blog_contents\SQL\1.png" alt="1"></p><p><img src="C:\Users\51402\blog\source\img\blog_contents\SQL\2.png" alt="2"></p><p><strong>例</strong> 按总平均值降序给出所有课程均及格但不包括C8的所有学生总平均成绩</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>sno, <span class="hljs-keyword">AVG</span>(G)<span class="hljs-keyword">FROM</span>SC<span class="hljs-keyword">WHERE</span> cno &lt;&gt; C8<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sno<span class="hljs-keyword">HAVING</span><span class="hljs-keyword">MIN</span>(G) &gt;= <span class="hljs-number">60</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">AVG</span>(G) <span class="hljs-keyword">DESC</span></code></pre><p>查询每一个供应商在每一种商品上为‘ c002’ 和‘ c003’两位客户订购的总数量（ 结果给出供应商的编号和名称、商品的编号和名称以及销售总数量</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.aid, a.aname, p.pid, p.pname, <span class="hljs-keyword">sum</span>(qty)<span class="hljs-keyword">FROM</span> Agents a, Products p, Orders o<span class="hljs-keyword">WHERE</span>a.aid=o.aid <span class="hljs-keyword">and</span> p.pid=o.pid <span class="hljs-keyword">and</span> (o.cid=<span class="hljs-string">&#x27;002&#x27;</span> <span class="hljs-keyword">or</span> o.cide=<span class="hljs-string">&#x27;003&#x27;</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.aid, a.aname, p.pid, p.pname</code></pre><h1 id="SELECT语句使用的一般规则"><a href="#SELECT语句使用的一般规则" class="headerlink" title="SELECT语句使用的一般规则"></a>SELECT语句使用的一般规则</h1><ol><li>合并FROM子句中的表（笛卡尔乘积）</li><li>利用WHERE子句中的条件进行元组选择，抛弃不满足WHERE条件的那些元组</li><li>根据GROUP BY子句对保留下来的元组进行分组</li><li>利用HAVING子句中的条件对分组后的元组集合(group)进行选择，抛弃不满足HAVING条件的那些元组集合</li><li>根据SELECT子句进行统计计算，生成结果关系的元组</li><li>根据ORDER BY子句对查询结果进行排序</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Liang-Barsky算法</title>
    <link href="/2020/10/14/Liang-Barsky/"/>
    <url>/2020/10/14/Liang-Barsky/</url>
    
    <content type="html"><![CDATA[<h2 id="算法背景"><a href="#算法背景" class="headerlink" title="算法背景"></a>算法背景</h2><p>&ensp;&ensp;&ensp;&ensp;Liang-Barsky算法由梁友栋和Barsky共同发表，是目前计算机图形学最经典的算法之一。他们认为线段裁剪的问题是：裁剪窗口是二维对象，而线段是一维对象，两个对象的维度不同不便比较。他们给出的解决思路是，将裁剪线段和裁剪窗口看为点集裁剪的结果是两个点集的交集。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>Liang-Barsky算法的主要思想有两部分：</strong></p><ul><li>用参数方程表示直线</li><li>将待裁剪直线看作是一个有方向的线</li></ul><h4 id="用参数方程表示直线"><a href="#用参数方程表示直线" class="headerlink" title="用参数方程表示直线"></a>用参数方程表示直线</h4><p>&ensp;&ensp;&ensp;&ensp;算法背景中提到Liang-Barsky算法的解决思路是，将裁剪线段和裁剪窗口看为点集裁剪的结果是两个点集的交集。<strong><em>那么裁剪线段如何转换点集呢？很显然用参数方程来表示直线。</em></strong></p><p>&ensp;&ensp;&ensp;&ensp;设待裁剪线段为$P_1P_2$，其中$P_1=(x_1,y_1),P_2=(x_2,y_2)$，用参数关系u表示有下图关系：</p><p><img src="/img/blog_contents/Liang-Barsky/1.jpg" alt=""></p><p>显见有如下关系：</p><script type="math/tex; mode=display">\begin{cases}x=x_1+u*(x2-x1)=x_1+u*\Delta x & 0\leq u \leq 1;\\y=y_1+u*(y2-y1)=y_1+u*\Delta y & 0\leq u \leq 1.\end{cases}</script><p>当$u=0$时，$x=x_1,y=y_1$也就是$P_1$；<br>当$u=1$时，$x=x_2,y=y_2$也就是$P_2$；<br>当$u=0.5$时，也就是该直线中点位置。</p><p>由上面三种情况可以很容易归纳出该图像的几何意义：也就是u值即可表示要裁剪线段的多少</p><h4 id="将待裁剪直线看作是一个有方向的线"><a href="#将待裁剪直线看作是一个有方向的线" class="headerlink" title="将待裁剪直线看作是一个有方向的线"></a>将待裁剪直线看作是一个有方向的线</h4><p>&ensp;&ensp;&ensp;&ensp;从上面我们知道u的取值可以决定线段要裁剪的多少，<strong><em>那么u到底如何取值变成了现在的首要目标？</em></strong></p><p>&ensp;&ensp;&ensp;&ensp;我们将四个窗口的交边分别定义成两类边：<strong>入边</strong>和<strong>出边</strong></p><ul><li>入边：指从裁剪窗口之外进入到裁剪窗口方向的边</li><li>出边：指从裁剪窗口之内延伸到窗口之外的边</li></ul><p>&ensp;&ensp;&ensp;&ensp;待裁剪线段和裁剪窗口必定会有四个交点（包括与裁剪窗口延长线的交点）分别设四个交点分别为$c_1,c_2,c_3,c_4$。设待裁剪直线为$P_1P_2$。则有下图：</p><p><img src="/img/blog_contents/Liang-Barsky/2.jpg" alt=""></p><p>&ensp;&ensp;&ensp;&ensp;显见要裁剪线段为$P_1$和$c_3$所夹线段，所以u的选取就要从$P_1,c_3$所对应$u_1,u_2$入手，则显见有如下关系式：</p><p>$u_1=max(c_1,c_2,P_1)$&ensp;&ensp;&ensp;&ensp;$u_1$是两个入边和$P_1$对应u值的最小值<br>$u_2=min(c_3,P_2,c_4)$&ensp;&ensp;&ensp;&ensp;$u_2$是两个出边和$P_2$对应u值的最大值</p><p>$u_1,u_2$的值要满足$u_1&lt;u_2$</p><p>&ensp;&ensp;&ensp;&ensp;<strong><em>只要求出$u_1,u_2$就能算出裁剪线段，但是要求出$u_1,u_2$的话，就又出现了两个新的问题：</em></strong></p><ul><li>如何算出四个交点$c_1,c_2,c_3,c_4$所对应的u值</li><li>如何确定哪两个边是出边，哪两个边是入边</li></ul><h2 id="四个交点对应的u值"><a href="#四个交点对应的u值" class="headerlink" title="四个交点对应的u值"></a>四个交点对应的u值</h2><p>在上面用参数方程表示直线章节中，我们提出了：</p><script type="math/tex; mode=display">\begin{cases}x=x_1+u*(x2-x1)=x_1+u*\Delta x & 0\leq u \leq 1;\\y=y_1+u*(y2-y1)=y_1+u*\Delta y & 0\leq u \leq 1.\end{cases}</script><p>&ensp;&ensp;&ensp;&ensp;我们不妨先考虑下，在u为何值时，$(x,y)$位于裁剪窗口之内？我们设裁剪窗口的上边界为$y_{max}$，下边界为$y_{min}$，左边界为$x_{min}$，右边界为$x_{max}$，结合上式有：</p><script type="math/tex; mode=display">\begin{cases}x_{min}\leq x_1+u*\Delta x \leq x_{max}\\ y_{min}\leq y_1+u*\Delta y \leq y_{max}\end{cases}</script><p>可以看出当</p><script type="math/tex; mode=display">\begin{cases}x_1+u*\Delta x=x_{min}\\ x_1+u*\Delta x=x_{max}\\y_1+u*\Delta y = y_{min}\\y_1+u*\Delta y = y_{max}\end{cases}</script><p>时，为裁剪直线和四个边界的交点值，所以我们可以很轻松的算出四个对应的u值，此处不在赘述。</p><h2 id="出入边的确定"><a href="#出入边的确定" class="headerlink" title="出入边的确定"></a>出入边的确定</h2><p>&ensp;&ensp;&ensp;&ensp;上面我们只提到了不等式的四个特殊情况，不失一般性，这里我们写出不等式的所有情况：</p><script type="math/tex; mode=display">\begin{cases}x_{min}\leq x_1+u*\Delta x \leq x_{max}\\ y_{min}\leq y_1+u*\Delta y \leq y_{max}\end{cases}</script><p>可化简为：</p><script type="math/tex; mode=display">\begin{cases}u*(-\Delta x) \leq x_1 - x_{min}\\u*\Delta x \leq x_{max} - x_1\\u*(-\Delta y) \leq y_1 - y_{min}\\u*\Delta y \leq y_{max} - y_1\\\end{cases}</script><p>上面四种情况可以归纳成</p><script type="math/tex; mode=display">u*p_k\leq q_k,k=1,2,3,4</script><p>使用穷举法可知：</p><ul><li>当$p_k&lt;0$时，线段从裁剪边界延长线的外部延伸到内部，也就是入边</li><li>当$p_k&gt;0$时，线段从裁剪边界延长线的内部延伸到外部，也就是出边</li></ul><p>&ensp;&ensp;&ensp;&ensp;显见，当$p_k=0$时，且$q_k&lt;0$，则线段完全在边界外；若$q_k\geq 0$，则线段完全在边界内</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Liang</span>-<span class="hljs-title">Barsky</span>(<span class="hljs-params">p_list, x_min, y_min, x_max, y_max</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;线段裁剪</span><span class="hljs-string"></span><span class="hljs-string">    :param p_list: (list of list of int: [[x0, y0], [x1, y1]]) 线段的起点和终点坐标</span><span class="hljs-string">    :param x_min: 裁剪窗口左上角x坐标</span><span class="hljs-string">    :param y_min: 裁剪窗口左上角y坐标</span><span class="hljs-string">    :param x_max: 裁剪窗口右下角x坐标</span><span class="hljs-string">    :param y_max: 裁剪窗口右下角y坐标</span><span class="hljs-string">    :return: (list of list of int: [[x_0, y_0], [x_1, y_1]]) 裁剪后线段的起点和终点坐标</span><span class="hljs-string">    &quot;&quot;&quot;</span>result = []    <span class="hljs-keyword">if</span> y_min &gt; y_max:        y_min, y_max = y_max, y_min    x0, y0 = p_list[<span class="hljs-number">0</span>]    x1, y1 = p_list[<span class="hljs-number">1</span>]    p = [x0-x1, x1-x0, y0-y1, y1-y0]    q = [x0-x_min, x_max-x0, y0-y_min, y_max-y0]    u0, u1 = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):        <span class="hljs-keyword">if</span> p[i] &lt; <span class="hljs-number">0</span>:            u0 = max(u0, q[i]/p[i])        <span class="hljs-keyword">elif</span> p[i] &gt; <span class="hljs-number">0</span>:            u1 = min(u1, q[i]/p[i])        <span class="hljs-keyword">elif</span> (p[i] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q[i] &lt; <span class="hljs-number">0</span>):            result = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]            <span class="hljs-keyword">return</span> result        <span class="hljs-keyword">if</span> u0 &gt; u1:            result = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]            <span class="hljs-keyword">return</span> result                res_x0 = int(x0 + u0*(x1-x0) + <span class="hljs-number">0.5</span>)    res_y0 = int(y0 + u0*(y1-y0) + <span class="hljs-number">0.5</span>)    res_x1 = int(x0 + u1*(x1-x0) + <span class="hljs-number">0.5</span>)    res_y1 = int(y0 + u1*(y1-y0) + <span class="hljs-number">0.5</span>)    result = [[res_x0, res_y0], [res_x1, res_y1]]    <span class="hljs-keyword">return</span> result</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cohen-Sutherland算法</title>
    <link href="/2020/10/11/Cohen-Sutherland/"/>
    <url>/2020/10/11/Cohen-Sutherland/</url>
    
    <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>&ensp;&ensp;&ensp;&ensp;编码算法是最早、最流行的线段裁剪算法，该算法采用区域检验的方法，能够快速有效地判断一条线段与裁剪窗口的位置关系，对完全接受或完全舍弃的线段无需求交，即可直接识别。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>&ensp;&ensp;&ensp;&ensp;编码算法将整个画布分成9个区域，如下图所示：</p><p><img src="/img/blog_contents/Cohen-Sutherland/1.jpg" alt=""></p><p>&ensp;&ensp;&ensp;&ensp;根据线段端点所在位置，给每个端点一个四位二进制码（称为区域码）。<strong>四位区域码的4位从左到右依次表示上、下、右、左</strong>。区域码的任何为赋值为1代表端点落在相应的区域中，否则为0。</p><h2 id="区域码的生成"><a href="#区域码的生成" class="headerlink" title="区域码的生成"></a>区域码的生成</h2><p>&ensp;&ensp;&ensp;&ensp;区域码的生成有两种方法：</p><p>&ensp;&ensp;&ensp;&ensp; <strong>1.比较法</strong></p><p>&ensp;&ensp;&ensp;&ensp; 根据上面提到的区域编码规则可知，在确定区域码每位的值时，可通过比较端点坐标值$(x,y)$和裁剪边界来确定区域码各位的值：</p><ul><li>如果$x&lt;x_{min}$，表示该点在裁剪窗口左边界的左边，则第1位置1，否则置0；</li><li>如果$x&gt;x_{max}$，表示该点在裁剪窗口右边界的右边，则第2位置1，否则置0；</li><li>如果$y&lt;y_{min}$，表示该点在裁剪窗口下边界的下边，则第3位置1，否则置0；</li><li>如果$y&lt;y_{max}$，表示该点在裁剪窗口上边界的上边，则第4位置1，否则置0；</li></ul><p>&ensp;&ensp;&ensp;&ensp; <strong>2.差值法</strong></p><p>&ensp;&ensp;&ensp;&ensp; 按照下列两步可以确定区域码各位的值：</p><ul><li>计算端点坐标和裁剪边界之间的差值</li><li>用各差值符号来设置区域码各位的值：第1位为$x-x_{min}$的符号位；第2位为$x-x{max}$；第3位为$y-y_{min}$的符号位；第4位为$y-y{max}$的符号位。</li></ul><h2 id="对线段的裁剪处理"><a href="#对线段的裁剪处理" class="headerlink" title="对线段的裁剪处理"></a>对线段的裁剪处理</h2><p>&ensp;&ensp;&ensp;&ensp;根据线段和裁剪窗口的关系可分三种情况处理：</p><p><img src="/img/blog_contents/Cohen-Sutherland/2.jpg" alt=""></p><ul><li><strong>线段完全在裁剪窗口之内</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;两个端点的区域码都为0000，则该线段完全在裁剪窗口内。如上图：$P_5P_6$</p><ul><li><strong>线段完全在裁剪窗口之外</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;两个端点的区域码相与的结果不为0000，则该线段完全在裁剪窗口之外。如上图：$P_9P_{10}$</p><ul><li><strong>其他</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;上图中$P_1P_2,P_3P_4,P_7P_8$都是此类问题；$P_1P_2,P_7P_8$显见属于一半落在窗口内一半落在窗口外，需要进行求交运算；而$P_3P_4$虽然完全落在窗口外但是条件不被第二种情况所适用也需要进行求交运算</p><p>&ensp;&ensp;&ensp;&ensp; <strong>求交过程</strong>：首先对线段外端点（落在窗口外的点）与一条裁剪边界比较来确定需要裁剪多少线段；然后，将线段的剩下部分与其他裁剪边界对比，直到该直线完全落在窗口内或者被舍弃。</p><p>&ensp;&ensp;&ensp;&ensp;实际算法实现只有在检测到区域码的某位为1时，才把线段和对应裁剪窗口进行求交运算。整个算法的流程如下图所示：</p><p><img src="/img/blog_contents/Cohen-Sutherland/3.jpg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Cohen</span>-<span class="hljs-title">Sutherland</span>(<span class="hljs-params">p_list, x_min, y_min, x_max, y_max</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;线段裁剪</span><span class="hljs-string">    :param p_list: (list of list of int: [[x0, y0], [x1, y1]]) 线段的起点和终点坐标</span><span class="hljs-string">    :param x_min: 裁剪窗口左上角x坐标</span><span class="hljs-string">    :param y_min: 裁剪窗口左上角y坐标</span><span class="hljs-string">    :param x_max: 裁剪窗口右下角x坐标</span><span class="hljs-string">    :param y_max: 裁剪窗口右下角y坐标</span><span class="hljs-string">    :return: (list of list of int: [[x_0, y_0], [x_1, y_1]]) 裁剪后线段的起点和终点坐标</span><span class="hljs-string">    &quot;&quot;&quot;</span>    result = []    <span class="hljs-keyword">if</span> y_min &gt; y_max:        y_min, y_max = y_max, y_min    x0, y0 = p_list[<span class="hljs-number">0</span>]    x1, y1 = p_list[<span class="hljs-number">1</span>]    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:        code0 = <span class="hljs-number">0</span> <span class="hljs-comment">#1_left, 2_right, 4_down, 8_up</span>        code1 = <span class="hljs-number">0</span> <span class="hljs-comment">#1_left, 2_right, 4_down, 8_up</span>        <span class="hljs-comment">#calc code0</span>        <span class="hljs-keyword">if</span> x0 &lt; x_min:            code0 += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> x0 &gt; x_max:            code0 += <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> y0 &lt; y_min:            code0 += <span class="hljs-number">4</span>        <span class="hljs-keyword">elif</span> y0 &gt; y_max:            code0 += <span class="hljs-number">8</span>        <span class="hljs-comment">#calc code1</span>        <span class="hljs-keyword">if</span> x1 &lt; x_min:            code1 += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> x1 &gt; x_max:            code1 += <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> y1 &lt; y_min:            code1 += <span class="hljs-number">4</span>        <span class="hljs-keyword">elif</span> y1 &gt; y_max:            code1 += <span class="hljs-number">8</span>        <span class="hljs-comment">#inside</span>        <span class="hljs-keyword">if</span> (code0 | code1) == <span class="hljs-number">0</span>:            result = [[x0, y0], [x1, y1]]            <span class="hljs-keyword">break</span>        <span class="hljs-comment">#outside</span>        <span class="hljs-keyword">elif</span> (code0 &amp; code1) != <span class="hljs-number">0</span>:            result.append([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])            result.append([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])            <span class="hljs-keyword">break</span>        <span class="hljs-comment">#otherwise</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> code0 == <span class="hljs-number">0</span>:                x0, x1 = x1, x0                y0, y1 = y1, y0                code0, code1 = code1, code0            <span class="hljs-comment">#1_left, 2_right, 4_down, 8_up</span>            <span class="hljs-keyword">if</span> (code0 &amp; <span class="hljs-number">1</span>):                y0 = int(y0 + ((x_min-x0) * (y0-y1)/(x0-x1)) + <span class="hljs-number">0.5</span>)                x0 = x_min            <span class="hljs-keyword">if</span> (code0 &amp; <span class="hljs-number">2</span>):                y0 = int(y0 + ((x_max-x0) * (y0-y1)/(x0-x1)) + <span class="hljs-number">0.5</span>)                x0 = x_max            <span class="hljs-keyword">if</span> (code0 &amp; <span class="hljs-number">4</span>):                x0 = int(x0 + ((y_min-y0) * (x0-x1)/(y0-y1)) + <span class="hljs-number">0.5</span>)                y0 = y_min            <span class="hljs-keyword">if</span> (code0 &amp; <span class="hljs-number">8</span>):                x0 = int(x0 + ((y_max-y0) * (x0-x1)/(y0-y1)) + <span class="hljs-number">0.5</span>)                y0 = y_max<span class="hljs-keyword">return</span> result</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二维几何变换</title>
    <link href="/2020/10/06/Two-Dimensional-Transformations/"/>
    <url>/2020/10/06/Two-Dimensional-Transformations/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;二维几何变换有如下几种：平移变换、比例变换、对称变换、旋转变换、错切变换</p><p>&emsp;&emsp;本文会给出：平移变换、旋转变换、比例变换、相对任意参考点的二维变换的算法和代码实现</p><h2 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h2><p>&emsp;&emsp;平移是指将物体沿直线路径从一个坐标位置$(x1,y1)$移动到另一个坐标位置$(x2,y2)$的变换。设$t_x$为沿X轴的平移量，$t_y$为沿Y轴的平移量。</p><h4 id="平移变换的二维表示为："><a href="#平移变换的二维表示为：" class="headerlink" title="平移变换的二维表示为："></a>平移变换的二维表示为：</h4><script type="math/tex; mode=display">\begin{cases}x_2=x_1+t_x\\ y_2=y_1+t_y\end{cases}</script><h4 id="平移变换的齐次表示为："><a href="#平移变换的齐次表示为：" class="headerlink" title="平移变换的齐次表示为："></a>平移变换的齐次表示为：</h4><script type="math/tex; mode=display">\begin{gathered}\begin{bmatrix} x_2 & y_2 & 1\end{bmatrix}=\begin{bmatrix} x_1 & y_1 & 1\end{bmatrix}\begin{bmatrix} 1 & 0 & 0\\0 & 1 & 0\\t_x & t_y & 1 \end{bmatrix}\end{gathered}</script><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translate</span>(<span class="hljs-params">p_list, dx, dy</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list:(list of list of int:[[x0,x1], [x1,y1], ...]) point set of p</span><span class="hljs-string">:param dx: (int) delta x</span><span class="hljs-string">:param dy: (int) delta y</span><span class="hljs-string">:result: (list of list of int:[[x0, y0], [x1, y1], ...])</span><span class="hljs-string">&quot;&quot;&quot;</span>n = len(p_list)result = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n):x2 = p_list[i][<span class="hljs-number">0</span>] + dxy2 = p_list[i][<span class="hljs-number">1</span>] + dyresult.append([x2, y2])<span class="hljs-keyword">return</span> result</code></pre><h2 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h2><p>&emsp;&emsp;二维旋转是将物体沿着xy平面内的圆弧路径重定位。旋转角$\theta$取值逆时针为正，顺时针为负</p><h4 id="旋转变换的二维表示"><a href="#旋转变换的二维表示" class="headerlink" title="旋转变换的二维表示"></a>旋转变换的二维表示</h4><p>&emsp;&emsp;如图所示：</p><p><img src="/img/blog_contents/Two-Dimensional-Transformations/1.jpg" alt=""></p><p>显见有如下关系：</p><script type="math/tex; mode=display">\begin{cases}x_2=r*cos(\alpha+\theta)=r*cos\alpha*cos\theta-r*sin\alpha*sin\theta\\y_2=r*sin(\alpha+\theta)=r*cos\alpha*sin\theta+r*sin\alpha*cos\theta\end{cases}</script><p>又因为有$x_1=r<em>cos\alpha,y_1=r</em>sin\alpha$，所以有</p><script type="math/tex; mode=display">\begin{cases}x_2=r*cos(\alpha+\theta)=x_1*cos\theta-y_1*sin\theta\\y_2=r*sin(\alpha+\theta)=x_1*sin\theta+y_1*cos\theta\end{cases}</script><h4 id="旋转变换的齐次表示"><a href="#旋转变换的齐次表示" class="headerlink" title="旋转变换的齐次表示"></a>旋转变换的齐次表示</h4><script type="math/tex; mode=display">\begin{gathered}\begin{bmatrix} x_2 & y_2 & 1\end{bmatrix}=\begin{bmatrix} x_1 & y_1 & 1\end{bmatrix}\begin{bmatrix} cos\theta & sin\theta & 0\\-sin\theta & cos\theta & 0\\0 & 0 & 1 \end{bmatrix}\end{gathered}</script><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate</span>(<span class="hljs-params">p_list, x, y, r</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list:(list of list of int:[[x0,x1], [x1,y1], ...]) point set of p</span><span class="hljs-string">:param x: (int) coordinate x</span><span class="hljs-string">:param y: (int) coordinate y</span><span class="hljs-string">:param r: (float) degree</span><span class="hljs-string">:result: (list of list of int:[[x0, y0], [x1, y1], ...])</span><span class="hljs-string">&quot;&quot;&quot;</span>n = len(p_list)sin = math.sin(math.radians(r))cos = math.cos(math.radians(r))result = []<span class="hljs-keyword">for</span> x1, y1 <span class="hljs-keyword">in</span> p_list:x2 = int(x1 * cos - y1 * sin)y2 = int(x1 * sin + y1 * cos)result.append([x2, y2])<span class="hljs-keyword">return</span> result</code></pre><h2 id="比例变换"><a href="#比例变换" class="headerlink" title="比例变换"></a>比例变换</h2><p>&emsp;&emsp;二维比例变换改变物体的尺寸。通过顶点值$(x_1,y_1)$乘以比例系数$S_x$和$S_y$得到变换的坐标$(x_2,y_2)$;</p><p>&emsp;&emsp;比例系数$S_x$为在x方向对物体的缩放，$S_y$在y方向的缩放。比例系数可以赋予任何正数，小于1缩小，大于1则放大；若$S_x=S_y$为等比例变换，若$S_x\neq S_y$则是非均匀比例变换。</p><h4 id="比例变换的二维表示为："><a href="#比例变换的二维表示为：" class="headerlink" title="比例变换的二维表示为："></a>比例变换的二维表示为：</h4><script type="math/tex; mode=display">\begin{cases}x_2=x_1*S_x\\ y_2=y_1*S_y\end{cases}</script><h4 id="比例变换的齐次表示为："><a href="#比例变换的齐次表示为：" class="headerlink" title="比例变换的齐次表示为："></a>比例变换的齐次表示为：</h4><script type="math/tex; mode=display">\begin{gathered}\begin{bmatrix} x_2 & y_2 & 1\end{bmatrix}=\begin{bmatrix} x_1 & y_1 & 1\end{bmatrix}\begin{bmatrix} S_x & 0 & 0\\0 & S_y & 0\\0 & 0 & 1 \end{bmatrix}\end{gathered}</script><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale</span>(<span class="hljs-params">p_list, x, y, s</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list:(list of list of int:[[x0,x1], [x1,y1], ...]) point set of p</span><span class="hljs-string">:param x: (int) coordinate x</span><span class="hljs-string">:param y: (int) coordinate y</span><span class="hljs-string">:param s: (float) times</span><span class="hljs-string">:result: (list of list of int:[[x0, y0], [x1, y1], ...])</span><span class="hljs-string">&quot;&quot;&quot;</span>n = len(p_list)result = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n):x2 = int(p_list[i][<span class="hljs-number">0</span>] + s)y2 = int(p_list[i][<span class="hljs-number">1</span>] + s)result.append([x2, y2])<span class="hljs-keyword">return</span> result</code></pre><h2 id="相对任意参考点的二维变换"><a href="#相对任意参考点的二维变换" class="headerlink" title="相对任意参考点的二维变换"></a>相对任意参考点的二维变换</h2><p>&emsp;&emsp;如果要对某参考点(x,y)作二维几何变换，比如比例变换，旋转变换等。变换过程如下：</p><ul><li>将参考点移至坐标原点</li><li>对原点进行二维几何变换</li><li>进行反平移，将参考点移回原来的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B-spline(B样条曲线)</title>
    <link href="/2020/09/27/B-spline/"/>
    <url>/2020/09/27/B-spline/</url>
    
    <content type="html"><![CDATA[<h2 id="算法产生背景"><a href="#算法产生背景" class="headerlink" title="算法产生背景"></a>算法产生背景</h2><p>Bezier曲线有以下几个不足点，所以导致出现了B-spline算法：</p><ul><li>一旦确定特征多边形，就确定了曲线的阶次</li><li>Bezier曲线拼接复杂（需要满足几何连续性，参数连续性等）</li><li>Bezier曲线不能作局部修改（只能整体修改）</li></ul><p>B-spline算法是整条曲线用一段一段的曲线连接而成，采用分段连续多段式生成</p><h2 id="B-spline曲线定义"><a href="#B-spline曲线定义" class="headerlink" title="B-spline曲线定义"></a>B-spline曲线定义</h2><p>B-spline曲线定义为：</p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^nP_iB_{i,k}(u) \qquad u\in [u_{k-1}, u_{n+1}]</script><p>其中$P_i$是特征多边形的顶点；$B_{i,k}$称为k阶（k-1次）基函数，B-spline算法阶数是次数加1，这是和Bezier算法的一个不同之处；定义域的解释之后会给出，先给出基函数算法。</p><p>B-spline基函数的求出算法应用最广泛的是deBoor-cox递推算法：</p><script type="math/tex; mode=display">B_{i,k}(u)=\frac{u-u_i}{u_{i+k-1}-u_i}*B_{i,k-1}{u}+\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}}*B_{i+1,k+1}(u)</script><script type="math/tex; mode=display">B_{i,1}(u)=\begin{cases}1 & u_i<u<u_{i+1};\\0 & Otherwise.\end{cases}</script><p><strong>规定0/0=0</strong></p><p>B-spline曲线的定义域为$u\in [u_{k-1}, u_{n+1}]$。设U为所有节点矢量的集合，显见节点表个数为$n+k+1$个。举例说明，当$n=4,k=4$时，有$U=\{u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\}$。第一项为$P_0B_{0,4}(u)$，由deBoor-cox算法可知，其涉及到$u_0$到$u_4$五个点；第二项同理，设计到$u_1$到$u_5$五个点；其余同理；所以可以画出区间对应坐标轴：</p><p><img src="/img/blog_contents/B-spline/img1.png" alt=""></p><p><strong>区间合法所需要的条件为</strong>：区间内必须有足够基函数与顶点对应，也即区间中基函数覆盖较多的区间才是一个合法区间。所以上例中对应的合法区间为$u\in [u_{3}, u_{5}]$也就是$u\in [u_{k-1}, u_{n+1}]$</p><h2 id="B-spline的类型划分"><a href="#B-spline的类型划分" class="headerlink" title="B-spline的类型划分"></a>B-spline的类型划分</h2><p>有均匀B样条曲线，准均匀B样条曲线，分段Bezier曲线，非均匀B样条曲线这几种方法，这里采用均匀B样条曲线的方法绘制曲线。</p><h4 id="均匀B样条曲线"><a href="#均匀B样条曲线" class="headerlink" title="均匀B样条曲线"></a>均匀B样条曲线</h4><p>定义：当节点沿参数轴均匀等距分布，即$u_{i+1}-u_i=C&gt;0$时，为均匀B样条函数，比如：$\{0,1,2,3,4,5,6\},\{0,0.2,0.4,0.6,0.8,1\}$</p><p>B-spline基函数($B_{i,k}$)的递推公式计算需要用到这里的思想。这里还使用上面当$n=4,k=4$的例子，从上面的定义可知，我们可以把节点集合$U=\{u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\}$写成这样$U=\{0,1,2,3,4,5,6,7,8\}$也即$u_0=0,u_1=1,…,u_8=8$，当然U也可以写成其他集合，因为计算的时候是一个比例，所以对计算结果并没有影响，综上就可以简单的算出对应基函数的值。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">B_spline</span>(<span class="hljs-params">p_list</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">result: (list of list of int:[[x0, y0], [x1, y1], ...])point on curve</span><span class="hljs-string">绘制三次(四阶)均匀B样条曲线</span><span class="hljs-string">&quot;&quot;&quot;</span>result = []n = len(p_list)k = <span class="hljs-number">4</span>u = k<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> (u &lt; n+<span class="hljs-number">1</span>):x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-comment">#calc P(u)</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n):B_ik = deBoor_Cox(u, k, i)x += B_ik * p_list[i][<span class="hljs-number">0</span>]y += B_ik * p_list[i][<span class="hljs-number">1</span>]result.append((int(x+<span class="hljs-number">0.5</span>), int(y+<span class="hljs-number">0.5</span>)))u += <span class="hljs-number">1</span>/<span class="hljs-number">20927</span> <span class="hljs-comment">#2020/09/27</span><span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deBoor_Cox</span>(<span class="hljs-params">u, k, i</span>):</span><span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>:<span class="hljs-keyword">if</span> i &lt;= u <span class="hljs-keyword">and</span> u &lt;= i+<span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_1, coef_2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">if</span> (u-i == <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> (i+k<span class="hljs-number">-1</span>-i == <span class="hljs-number">0</span>):coef_1 = <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_1 = (u-i) / (i+k<span class="hljs-number">-1</span>-i)<span class="hljs-keyword">if</span> (i+k-u == <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> (i+k-i<span class="hljs-number">-1</span> == <span class="hljs-number">0</span>)coef_2 = <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_2 = (i+k-u) / (i+k-i<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> coef_1 * deBoor_Cox(u, k<span class="hljs-number">-1</span>, i) + coef_2 * deBoox_Cox(u, k<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tetris99</title>
    <link href="/2020/09/25/Tetris99/"/>
    <url>/2020/09/25/Tetris99/</url>
    
    <content type="html"><![CDATA[<h2 id="笔者游戏情况"><a href="#笔者游戏情况" class="headerlink" title="笔者游戏情况"></a>笔者游戏情况</h2><ul><li>游戏时长55小时</li><li>已购买dlc部分</li><li>多次获得普通模式Tetris第一</li><li>Ver. 2.1.0</li></ul><h2 id="游戏优点"><a href="#游戏优点" class="headerlink" title="游戏优点"></a>游戏优点</h2><ul><li>成熟的玩法，百听不厌的背景音乐</li><li>易于上手难于精通</li><li>良好的游戏体验</li><li>大逃杀模式与俄罗斯方块的完美结合</li></ul><h2 id="游戏缺点"><a href="#游戏缺点" class="headerlink" title="游戏缺点"></a>游戏缺点</h2><ul><li>dlc付费内容有些许匮乏</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>&emsp; 一个由四格骨牌组成的美妙世界！在此有必要说明一下现代俄罗斯方块和传统俄罗斯方块的不同，两者主要区别在于现代俄罗斯方块有着更加丰富的旋转系统，使得游戏的可玩性大大提升。而Tetris99所采用的正是现代俄罗斯方块的规则，非常值得认知还停留在传统俄罗斯方块的朋友游玩。</p><p>&emsp; Tetris99的优点毋庸置疑，大逃杀和俄罗斯方块两个几乎不相干的关键词被Tetris99巧妙的结合在一起，但是可玩性上却产生了奇妙反应。其良好的保护机制使得就算是刚上手的新人也可以紧张又轻松的玩完整局游戏。</p><p>&emsp; 当然就算是这样一个近乎完美的免费游戏，如果在购买了游戏dlc的情况下，与免费内容一经对比也会显得稍有逊色。游戏的dlc售价70人民币左右，dlc包含以下内容：</p><ul><li>马拉松模式（150行，999行）</li><li>COM Tetris99大作战（和99个机器人吃鸡）</li><li>本地n人对战（整局游戏由n个玩家，99-n个电脑组成）</li></ul><p>&emsp; 在玩的正上瘾的时候，购入dlc可谓是被泼了一盆凉水；购入dlc的玩家粗略分为两种：进阶玩家和娱乐玩家。对于一个想要进阶的玩家只有一个马拉松模式可以用来练习，缺少40行等模式（不过硬要是折中倒是也是凑合）其他几个dlc内容又显得可有可无；娱乐玩家购入dlc最大的优点是可以通过玩COM大作战来体验一下吃鸡喜悦（雾）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp; 质量上乘的免费游戏，就算在现如今游戏画面逼真，优秀游戏泛滥的年代，Tetris99也是一个能独当一面的优秀游戏。最后引用一下俄罗斯方块贴吧吧简介：俄罗斯方块看似简单但却变化无穷。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bezier算法</title>
    <link href="/2020/09/25/Bezier/"/>
    <url>/2020/09/25/Bezier/</url>
    
    <content type="html"><![CDATA[<h2 id="bezier算法的背景"><a href="#bezier算法的背景" class="headerlink" title="bezier算法的背景"></a>bezier算法的背景</h2><p>vm公司设计出了一个原型车——moon,这样的：</p><p><img src="/img/blog_contents/Bezier/moon.png" alt=""></p><p>产品经理一看觉得有点抽象，他使用了Bezier算法改进了一下原型车，变成了这样(红线部分)：</p><p><img src="/img/blog_contents/Bezier/moon_v1.png" alt=""></p><p>Bezier算法在做的事，通过光滑的曲线逼近用户给出的折线段(准确的来说是给出的<strong>控制顶点</strong>，即图中蓝色的点。这些点连线构成的多边形又叫<strong>特征多边形</strong>)</p><h2 id="Bezier曲线的定义"><a href="#Bezier曲线的定义" class="headerlink" title="Bezier曲线的定义"></a>Bezier曲线的定义</h2><p>Bezier算法围绕着Bezier曲线展开，Bezier曲线的定义为：</p><script type="math/tex; mode=display">p(t)=\sum_{i=0}^n P_i B_{i,n}(t)\qquad t \in \mathbf{[0,1]}</script><p>其中P(i)为控制顶点，n表示有n+1个控制顶点,$B_{i,n}(t)$,为Bernstein基函数;其中$B_{i,n}=C_n^i*t^i(1-t)^{n-i}$</p><p>肯定有人会和笔者一样，疑惑为什么会突然出现一个Bernstein函数，大致的原因是这样：提出算法的Bezier当时给出了一个较为复杂的Bezier曲线函数，在提出若干年后施法中教授<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98">[1]</span></a></sup>给出了证明过程，可见原式的复杂性；而后Forrest在后来证明出原基函数可以简化成Bernstein基函数。</p><h2 id="参数t的重要性"><a href="#参数t的重要性" class="headerlink" title="参数t的重要性"></a>参数t的重要性</h2><p>当上式t从0取到1就是对应的Bezier曲线图像。$t$从0选取到1才能绘制出整个图像，不失一般性，当绘制一个二次Bezier曲线时，$n=2$，有三个控制顶点，若每个控制顶点对应的$t=0$，显见必定只能得到一个点，<strong>所以t的选取也至关重要</strong>，举个例子：</p><ul><li><p>1.三个控制顶点分别为(0,0),(200,100),(400,0);则图像如下:</p><p><img src="/img/blog_contents/Bezier/frist.png" alt=""></p></li></ul><p>取t分别为$t_1=0,t_2=\frac{1}{2},t_3=1$非常合理</p><ul><li>2.但若三个控制点分别取(0,0),(300,50),(400,0)时，则图像如下：</li></ul><p><img src="/img/blog_contents/Bezier/second.png" alt=""></p><p>显然此时仍然取$t_1=0,t_2=\frac{1}{2},t_3=1$有些许欠妥</p><p>所以t的取值也是重中之重，只有t的值选取的好才能让曲线更加贴合</p><h4 id="t的选取"><a href="#t的选取" class="headerlink" title="t的选取"></a>t的选取</h4><p>t的选取有这几种方法：均匀参数化、累加弦长参数化，向心参数化法；这里只介绍第一种均匀参数化方法。笔者后面展示的代码也是选用了这种方法。</p><p><strong>均匀参数化</strong>：节点在参数轴均匀分布，比如：0，$\frac{1}{100}$，$\frac{2}{100}$…，1</p><h2 id="Bezier生成曲线算法"><a href="#Bezier生成曲线算法" class="headerlink" title="Bezier生成曲线算法"></a>Bezier生成曲线算法</h2><p>Bezier生成曲线算法有两种：其中一种就是用上面提到的方法直接生成曲线，不过其中涉及到大量组合数的计算，较为耗时；另外一种算法是<strong>de Casteljau</strong>递推算法生成曲线,递推式为：</p><p>$P_i^r=\begin{cases}  p_i &amp; r=0;\\ (1-t)P_i^{r-1}+tP_{i+1}^{r-1} &amp;r=1,…,n;  &amp;i=0,…,n-r \end{cases}$</p><p>举例：不失一般性，假设绘制二次Bezier曲线，当$t=\frac{1}{3}$时，设有$P_0,P_1,P_2$三个点，在线段$P_0P_1$三分之一处画出$P_0^1$；在线段$P_1P_2$三分之一处画出$P_1^1$；连接两点$P_0^1P_1^1$，在线段$P_0^1P_1^1$三分之一处画出$P_0^2$过程如下：</p><p><img src="/img/blog_contents/Bezier/step_all.gif" alt=""></p><p>显见递推式的几何意义为：</p><p><img src="/img/blog_contents/Bezier/result.png" alt=""></p><p><strong>下面是具体绘制过程：</strong><br>一次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Linear.gif" alt=""></p><p>二次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Quadratic.gif" alt=""></p><p>三次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Cubic.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_curve</span>(<span class="hljs-params">p_list</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">result: (list of list of int:[[x0, y0], [x1, y1], ...])point on curve</span><span class="hljs-string">&quot;&quot;&quot;</span>result = []P = []P = p_list.copy()r = len(p_list)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">20923</span>): <span class="hljs-comment">#2020/09/23</span>t = i/<span class="hljs-number">20923</span>x, y = de_Casteljau(r, P, t)result.append((x, y))<span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">de_Casteljau</span>(<span class="hljs-params">n, pointSet_p, t</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param n: number of control</span><span class="hljs-string">:param pointSet_p: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">:param t: t</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">while</span>(n):<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>):P[i][<span class="hljs-number">0</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">0</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]P[i][<span class="hljs-number">1</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">1</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]n -= <span class="hljs-number">1</span>P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>)P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>)<span class="hljs-keyword">return</span> P[<span class="hljs-number">0</span>]</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八皇后问题</title>
    <link href="/2020/09/24/Eight-Queens/"/>
    <url>/2020/09/24/Eight-Queens/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><p><strong>输入格式</strong><br>一行一个正整数n，表示棋盘是n*n大小的</p><p><strong>输出格式</strong><br>有多少种摆法</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>深搜、标记以及回溯</p><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><p>介绍顺序：标记-&gt;深搜-&gt;回溯</p><h4 id="1-标记"><a href="#1-标记" class="headerlink" title="1.标记"></a>1.标记</h4><p> 使用数组记录无法下棋的部分：</p><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>];</code></pre><p>当置为1时，即为无法再放置的标记，具体标记内容：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记j列不能再放置</span>flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线 </span>flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线</span></code></pre><p>举个例子，当棋盘为4*4时：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span><span class="hljs-comment">// i=2,j=3；显见在红线处都应该设为1</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ij.jpg" alt=""></p><pre><code class="hljs cpp">flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">// i=2,j=3；显见在红线处应都无法放置</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ijn.jpg" alt=""></p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> res; <span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>]; <span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span> (i &gt; n) &#123;res++;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> ((flag[<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">2</span>][i + j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">3</span>][i - j + n] == <span class="hljs-number">0</span>)) &#123;flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>dfs(i + <span class="hljs-number">1</span>);flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n;dfs(<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span> &lt;&lt; res;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
