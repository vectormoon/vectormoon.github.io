<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tetris99</title>
    <link href="/2020/09/25/Tetris99/"/>
    <url>/2020/09/25/Tetris99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bezier算法</title>
    <link href="/2020/09/25/Bezier/"/>
    <url>/2020/09/25/Bezier/</url>
    
    <content type="html"><![CDATA[<h2 id="bezier算法的背景"><a href="#bezier算法的背景" class="headerlink" title="bezier算法的背景"></a>bezier算法的背景</h2><p>vm公司设计出了一个原型车——moon,这样的：</p><p><img src="/img/blog_contents/Bezier/moon.png" alt=""></p><p>产品经理一看觉得有点抽象，他使用了Bezier算法改进了一下原型车，变成了这样(红线部分)：</p><p><img src="/img/blog_contents/Bezier/moon_v1.png" alt=""></p><p>Bezier算法在做的事，通过光滑的曲线逼近用户给出的折线段(准确的来说是给出的<strong>控制顶点</strong>，即图中蓝色的点。这些点连线构成的多边形又叫<strong>特征多边形</strong>)</p><h2 id="Bezier曲线的定义"><a href="#Bezier曲线的定义" class="headerlink" title="Bezier曲线的定义"></a>Bezier曲线的定义</h2><p>Bezier算法围绕着Bezier曲线展开，Bezier曲线的定义为：</p><script type="math/tex; mode=display">p(t)=\sum_{i=0}^n P_i B_{i,n}(t)\qquad t \in \mathbf{[0,1]}</script><p>其中P(i)为控制顶点，n表示有n+1个控制顶点,$B_{i,n}(t)$,为Bernstein基函数;其中$B_{i,n}=C_n^i*t^i(1-t)^{n-i}$</p><p>肯定有人会和笔者一样，疑惑为什么会突然出现一个Bernstein函数，大致的原因是这样：提出算法的Bezier当时给出了一个较为复杂的Bezier曲线函数，在提出若干年后施法中教授<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98">[1]</span></a></sup>给出了证明过程，可见原式的复杂性；而后Forrest在后来证明出原基函数可以简化成Bernstein基函数。</p><h2 id="参数t的重要性"><a href="#参数t的重要性" class="headerlink" title="参数t的重要性"></a>参数t的重要性</h2><p>当上式t从0取到1就是对应的Bezier曲线图像。$t$从0选取到1才能绘制出整个图像，不失一般性，当绘制一个二次Bezier曲线时，$n=2$，有三个控制顶点，若每个控制顶点对应的$t=0$，显见必定只能得到一个点，<strong>所以t的选取也至关重要</strong>，举个例子：</p><ul><li><p>1.三个控制顶点分别为(0,0),(200,100),(400,0);则图像如下:</p><p><img src="/img/blog_contents/Bezier/frist.png" alt=""></p></li></ul><p>取t分别为$t_1=0,t_2=\frac{1}{2},t_3=1$非常合理</p><ul><li>2.但若三个控制点分别取(0,0),(300,50),(400,0)时，则图像如下：</li></ul><p><img src="/img/blog_contents/Bezier/second.png" alt=""></p><p>显然此时仍然取$t_1=0,t_2=\frac{1}{2},t_3=1$有些许欠妥</p><p>所以t的取值也是重中之重，只有t的值选取的好才能让曲线更加贴合</p><h4 id="t的选取"><a href="#t的选取" class="headerlink" title="t的选取"></a>t的选取</h4><p>t的选取有这几种方法：均匀参数化、累加弦长参数化，向心参数化法；这里只介绍第一种均匀参数化方法。笔者后面展示的代码也是选用了这种方法。</p><p><strong>均匀参数化</strong>：节点在参数轴均匀分布，比如：0，$\frac{1}{100}$，$\frac{2}{100}$…，1</p><h2 id="Bezier生成曲线算法"><a href="#Bezier生成曲线算法" class="headerlink" title="Bezier生成曲线算法"></a>Bezier生成曲线算法</h2><p>Bezier生成曲线算法有两种：其中一种就是用上面提到的方法直接生成曲线，不过其中涉及到大量组合数的计算，较为耗时；另外一种算法是<strong>de Casteljau</strong>递推算法生成曲线,递推式为：</p><p>$P_i^r=\begin{cases}  p_i &amp; r=0;\\ (1-t)P_i^{r-1}+tP_{i+1}^{r-1} &amp;r=1,…,n;  &amp;i=0,…,n-r \end{cases}$</p><p>举例：不失一般性，假设绘制二次Bezier曲线，当$t=\frac{1}{3}$时，设有$P_0,P_1,P_2$三个点，在线段$P_0P_1$三分之一处画出$P_0^1$；在线段$P_1P_2$三分之一处画出$P_1^1$；连接两点$P_0^1P_1^1$，在线段$P_0^1P_1^1$三分之一处画出$P_0^2$过程如下：</p><p><img src="/img/blog_contents/Bezier/step_all.gif" alt=""></p><p>显见递推式的几何意义为：</p><p><img src="/img/blog_contents/Bezier/result.png" alt=""></p><p><strong>下面是具体绘制过程：</strong><br>一次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Linear.gif" alt=""></p><p>二次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Quadratic.gif" alt=""></p><p>三次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Cubic.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_curve</span>(<span class="hljs-params">p_list</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">result: (list of list of int:[[x0, y0], [x1, y1], ...])point on curve</span><span class="hljs-string">&quot;&quot;&quot;</span>result = []P = []P = p_list.copy()r = len(p_list)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">20923</span>): <span class="hljs-comment">#2020/09/23</span>t = i/<span class="hljs-number">20923</span>x, y = de_Casteljau(r, P, t)result.append((x, y))<span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">de_Casteljau</span>(<span class="hljs-params">n, pointSet_p, t</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param n: number of control</span><span class="hljs-string">:param pointSet_p: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">:param t: t</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">while</span>(n):<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>):P[i][<span class="hljs-number">0</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">0</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]P[i][<span class="hljs-number">1</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">1</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]n -= <span class="hljs-number">1</span>P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>)P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>)<span class="hljs-keyword">return</span> P[<span class="hljs-number">0</span>]</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八皇后问题</title>
    <link href="/2020/09/24/Eight-Queens/"/>
    <url>/2020/09/24/Eight-Queens/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<br><strong>输入格式</strong><br>一行一个正整数n，表示棋盘是n<em>n大小的<br><em>*输出格式</em></em><br>有多少种摆法</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p> 深搜、标记以及回溯</p><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><p>介绍顺序：标记-&gt;深搜-&gt;回溯</p><h4 id="1-标记"><a href="#1-标记" class="headerlink" title="1.标记"></a>1.标记</h4><p> 使用数组记录无法下棋的部分：</p><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>];</code></pre><p>当置为1时，即为无法再放置的标记，具体标记内容：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记j列不能再放置</span>flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线 </span>flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线</span></code></pre><p>举个例子，当棋盘为4*4时：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span><span class="hljs-comment">// i=2,j=3；显见在红线处都应该设为1</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ij.jpg" alt=""></p><pre><code class="hljs cpp">flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">// i=2,j=3；显见在红线处应都无法放置</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ijn.jpg" alt=""></p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> res; <span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>]; <span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span> (i &gt; n) &#123;res++;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> ((flag[<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">2</span>][i + j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">3</span>][i - j + n] == <span class="hljs-number">0</span>)) &#123;flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>dfs(i + <span class="hljs-number">1</span>);flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n;dfs(<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span> &lt;&lt; res;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
