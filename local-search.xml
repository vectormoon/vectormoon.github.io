<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>B-spline(B样条曲线)</title>
    <link href="/2020/09/27/B-spline/"/>
    <url>/2020/09/27/B-spline/</url>
    
    <content type="html"><![CDATA[<h2 id="算法产生背景"><a href="#算法产生背景" class="headerlink" title="算法产生背景"></a>算法产生背景</h2><p>Bezier曲线有以下几个不足点，所以导致出现了B-spline算法：</p><ul><li>一旦确定特征多边形，就确定了曲线的阶次</li><li>Bezier曲线拼接复杂（需要满足几何连续性，参数连续性等）</li><li>Bezier曲线不能作局部修改（只能整体修改）</li></ul><p>B-spline算法是整条曲线用一段一段的曲线连接而成，采用分段连续多段式生成</p><h2 id="B-spline曲线定义"><a href="#B-spline曲线定义" class="headerlink" title="B-spline曲线定义"></a>B-spline曲线定义</h2><p>B-spline曲线定义为：</p><script type="math/tex; mode=display">P(u)=\sum_{i=0}^nP_iB_{i,k}(u) \qquad u\in [u_{k-1}, u_{n+1}]</script><p>其中$P_i$是特征多边形的顶点；$B_{i,k}$称为k阶（k-1次）基函数，B-spline算法阶数是次数加1，这是和Bezier算法的一个不同之处；定义域的解释之后会给出，先给出基函数算法。</p><p>B-spline基函数的求出算法应用最广泛的是deBoor-cox递推算法：</p><script type="math/tex; mode=display">B_{i,k}(u)=\frac{u-u_i}{u_{i+k-1}-u_i}*B_{i,k-1}{u}+\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}}*B_{i+1,k+1}(u)</script><script type="math/tex; mode=display">B_{i,1}(u)=\begin{cases}1 & u_i<u<u_{i+1};\\0 & Otherwise.\end{cases}</script><p><strong>规定0/0=0</strong></p><p>B-spline曲线的定义域为$u\in [u_{k-1}, u_{n+1}]$。设U为所有节点矢量的集合，显见节点表个数为$n+k+1$个。举例说明，当$n=4,k=4$时，有$U=\{u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\}$。第一项为$P_0B_{0,4}(u)$，由deBoor-cox算法可知，其涉及到$u_0$到$u_4$五个点；第二项同理，设计到$u_1$到$u_5$五个点；其余同理；所以可以画出区间对应坐标轴：</p><p><img src="/img/blog_contents/B-spline/img1.png" alt=""></p><p><strong>区间合法所需要的条件为</strong>：区间内必须有足够基函数与顶点对应，也即区间中基函数覆盖较多的区间才是一个合法区间。所以上例中对应的合法区间为$u\in [u_{3}, u_{5}]$也就是$u\in [u_{k-1}, u_{n+1}]$</p><h2 id="B-spline的类型划分"><a href="#B-spline的类型划分" class="headerlink" title="B-spline的类型划分"></a>B-spline的类型划分</h2><p>有均匀B样条曲线，准均匀B样条曲线，分段Bezier曲线，非均匀B样条曲线这几种方法，这里采用均匀B样条曲线的方法绘制曲线。</p><h4 id="均匀B样条曲线"><a href="#均匀B样条曲线" class="headerlink" title="均匀B样条曲线"></a>均匀B样条曲线</h4><p>定义：当节点沿参数轴均匀等距分布，即$u_{i+1}-u_i=C&gt;0$时，为均匀B样条函数，比如：$\{0,1,2,3,4,5,6\},\{0,0.2,0.4,0.6,0.8,1\}$</p><p>B-spline基函数($B_{i,k}$)的递推公式计算需要用到这里的思想。这里还使用上面当$n=4,k=4$的例子，从上面的定义可知，我们可以把节点集合$U=\{u_0,u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8\}$写成这样$U=\{0,1,2,3,4,5,6,7,8\}$也即$u_0=0,u_1=1,…,u_8=8$，当然U也可以写成其他集合，因为计算的时候是一个比例，所以对计算结果并没有影响，综上就可以简单的算出对应基函数的值。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">B_spline</span>(<span class="hljs-params">p_list</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">result: (list of list of int:[[x0, y0], [x1, y1], ...])point on curve</span><span class="hljs-string">绘制三次(四阶)均匀B样条曲线</span><span class="hljs-string">&quot;&quot;&quot;</span>result = []n = len(p_list)k = <span class="hljs-number">4</span>u = k<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> (u &lt; n+<span class="hljs-number">1</span>):x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-comment">#calc P(u)</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n):B_ik = deBoor_Cox(u, k, i)x += B_ik * p_list[i][<span class="hljs-number">0</span>]y += B_ik * p_list[i][<span class="hljs-number">1</span>]result.append((int(x+<span class="hljs-number">0.5</span>), int(y+<span class="hljs-number">0.5</span>)))u += <span class="hljs-number">1</span>/<span class="hljs-number">20927</span> <span class="hljs-comment">#2020/09/27</span><span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deBoor_Cox</span>(<span class="hljs-params">u, k, i</span>):</span><span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>:<span class="hljs-keyword">if</span> i &lt;= u <span class="hljs-keyword">and</span> u &lt;= i+<span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_1, coef_2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">if</span> (u-i == <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> (i+k<span class="hljs-number">-1</span>-i == <span class="hljs-number">0</span>):coef_1 = <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_1 = (u-i) / (i+k<span class="hljs-number">-1</span>-i)<span class="hljs-keyword">if</span> (i+k-u == <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> (i+k-i<span class="hljs-number">-1</span> == <span class="hljs-number">0</span>)coef_2 = <span class="hljs-number">0</span><span class="hljs-keyword">else</span>:coef_2 = (i+k-u) / (i+k-i<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> coef_1 * deBoor_Cox(u, k<span class="hljs-number">-1</span>, i) + coef_2 * deBoox_Cox(u, k<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tetris99</title>
    <link href="/2020/09/25/Tetris99/"/>
    <url>/2020/09/25/Tetris99/</url>
    
    <content type="html"><![CDATA[<h2 id="笔者游戏情况"><a href="#笔者游戏情况" class="headerlink" title="笔者游戏情况"></a>笔者游戏情况</h2><ul><li>游戏时长55小时</li><li>已购买dlc部分</li><li>多次获得普通模式Tetris第一</li><li>Ver. 2.1.0</li></ul><h2 id="游戏优点"><a href="#游戏优点" class="headerlink" title="游戏优点"></a>游戏优点</h2><ul><li>成熟的玩法，百听不厌的背景音乐</li><li>易于上手难于精通</li><li>良好的游戏体验</li><li>大逃杀模式与俄罗斯方块的完美结合</li></ul><h2 id="游戏缺点"><a href="#游戏缺点" class="headerlink" title="游戏缺点"></a>游戏缺点</h2><ul><li>dlc付费内容有些许匮乏</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>&emsp; 一个由四格骨牌组成的美妙世界！在此有必要说明一下现代俄罗斯方块和传统俄罗斯方块的不同，两者主要区别在于现代俄罗斯方块有着更加丰富的旋转系统，使得游戏的可玩性大大提升。而Tetris99所采用的正是现代俄罗斯方块的规则，非常值得认知还停留在传统俄罗斯方块的朋友游玩。</p><p>&emsp; Tetris99的优点毋庸置疑，大逃杀和俄罗斯方块两个几乎不相干的关键词被Tetris99巧妙的结合在一起，但是可玩性上却产生了奇妙反应。其良好的保护机制使得就算是刚上手的新人也可以紧张又轻松的玩完整局游戏。</p><p>&emsp; 当然就算是这样一个近乎完美的免费游戏，如果在购买了游戏dlc的情况下，与免费内容一经对比也会显得稍有逊色。游戏的dlc售价70人民币左右，dlc包含以下内容：</p><ul><li>马拉松模式（150行，999行）</li><li>CPU Tetris99大作战（和99个机器人吃鸡）</li><li>本地n人对战（整局游戏由n个玩家，99-n个电脑组成）</li></ul><p>&emsp; 在玩的正上瘾的时候，购入dlc可谓是被泼了一盆凉水；购入dlc的玩家粗略分为两种：进阶玩家和娱乐玩家。对于一个想要进阶的玩家只有一个马拉松模式可以用来练习，缺少40行等模式（不过硬要是折中倒是也是凑合）其他几个dlc内容又显得可有可无；娱乐玩家购入dlc最大的优点是可以通过玩CPU大作战来体验一下吃鸡喜悦（雾）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp; 质量上乘的免费游戏，就算在现如今游戏画面逼真，优秀游戏泛滥的年代，Tetris99也是一个能独当一面的优秀游戏。最后引用一下俄罗斯方块贴吧吧简介：俄罗斯方块看似简单但却变化无穷。</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bezier算法</title>
    <link href="/2020/09/25/Bezier/"/>
    <url>/2020/09/25/Bezier/</url>
    
    <content type="html"><![CDATA[<h2 id="bezier算法的背景"><a href="#bezier算法的背景" class="headerlink" title="bezier算法的背景"></a>bezier算法的背景</h2><p>vm公司设计出了一个原型车——moon,这样的：</p><p><img src="/img/blog_contents/Bezier/moon.png" alt=""></p><p>产品经理一看觉得有点抽象，他使用了Bezier算法改进了一下原型车，变成了这样(红线部分)：</p><p><img src="/img/blog_contents/Bezier/moon_v1.png" alt=""></p><p>Bezier算法在做的事，通过光滑的曲线逼近用户给出的折线段(准确的来说是给出的<strong>控制顶点</strong>，即图中蓝色的点。这些点连线构成的多边形又叫<strong>特征多边形</strong>)</p><h2 id="Bezier曲线的定义"><a href="#Bezier曲线的定义" class="headerlink" title="Bezier曲线的定义"></a>Bezier曲线的定义</h2><p>Bezier算法围绕着Bezier曲线展开，Bezier曲线的定义为：</p><script type="math/tex; mode=display">p(t)=\sum_{i=0}^n P_i B_{i,n}(t)\qquad t \in \mathbf{[0,1]}</script><p>其中P(i)为控制顶点，n表示有n+1个控制顶点,$B_{i,n}(t)$,为Bernstein基函数;其中$B_{i,n}=C_n^i*t^i(1-t)^{n-i}$</p><p>肯定有人会和笔者一样，疑惑为什么会突然出现一个Bernstein函数，大致的原因是这样：提出算法的Bezier当时给出了一个较为复杂的Bezier曲线函数，在提出若干年后施法中教授<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98">[1]</span></a></sup>给出了证明过程，可见原式的复杂性；而后Forrest在后来证明出原基函数可以简化成Bernstein基函数。</p><h2 id="参数t的重要性"><a href="#参数t的重要性" class="headerlink" title="参数t的重要性"></a>参数t的重要性</h2><p>当上式t从0取到1就是对应的Bezier曲线图像。$t$从0选取到1才能绘制出整个图像，不失一般性，当绘制一个二次Bezier曲线时，$n=2$，有三个控制顶点，若每个控制顶点对应的$t=0$，显见必定只能得到一个点，<strong>所以t的选取也至关重要</strong>，举个例子：</p><ul><li><p>1.三个控制顶点分别为(0,0),(200,100),(400,0);则图像如下:</p><p><img src="/img/blog_contents/Bezier/frist.png" alt=""></p></li></ul><p>取t分别为$t_1=0,t_2=\frac{1}{2},t_3=1$非常合理</p><ul><li>2.但若三个控制点分别取(0,0),(300,50),(400,0)时，则图像如下：</li></ul><p><img src="/img/blog_contents/Bezier/second.png" alt=""></p><p>显然此时仍然取$t_1=0,t_2=\frac{1}{2},t_3=1$有些许欠妥</p><p>所以t的取值也是重中之重，只有t的值选取的好才能让曲线更加贴合</p><h4 id="t的选取"><a href="#t的选取" class="headerlink" title="t的选取"></a>t的选取</h4><p>t的选取有这几种方法：均匀参数化、累加弦长参数化，向心参数化法；这里只介绍第一种均匀参数化方法。笔者后面展示的代码也是选用了这种方法。</p><p><strong>均匀参数化</strong>：节点在参数轴均匀分布，比如：0，$\frac{1}{100}$，$\frac{2}{100}$…，1</p><h2 id="Bezier生成曲线算法"><a href="#Bezier生成曲线算法" class="headerlink" title="Bezier生成曲线算法"></a>Bezier生成曲线算法</h2><p>Bezier生成曲线算法有两种：其中一种就是用上面提到的方法直接生成曲线，不过其中涉及到大量组合数的计算，较为耗时；另外一种算法是<strong>de Casteljau</strong>递推算法生成曲线,递推式为：</p><p>$P_i^r=\begin{cases}  p_i &amp; r=0;\\ (1-t)P_i^{r-1}+tP_{i+1}^{r-1} &amp;r=1,…,n;  &amp;i=0,…,n-r \end{cases}$</p><p>举例：不失一般性，假设绘制二次Bezier曲线，当$t=\frac{1}{3}$时，设有$P_0,P_1,P_2$三个点，在线段$P_0P_1$三分之一处画出$P_0^1$；在线段$P_1P_2$三分之一处画出$P_1^1$；连接两点$P_0^1P_1^1$，在线段$P_0^1P_1^1$三分之一处画出$P_0^2$过程如下：</p><p><img src="/img/blog_contents/Bezier/step_all.gif" alt=""></p><p>显见递推式的几何意义为：</p><p><img src="/img/blog_contents/Bezier/result.png" alt=""></p><p><strong>下面是具体绘制过程：</strong><br>一次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Linear.gif" alt=""></p><p>二次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Quadratic.gif" alt=""></p><p>三次Bezier曲线</p><p><img src="/img/blog_contents/Bezier/Cubic.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_curve</span>(<span class="hljs-params">p_list</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param p_list: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">result: (list of list of int:[[x0, y0], [x1, y1], ...])point on curve</span><span class="hljs-string">&quot;&quot;&quot;</span>result = []P = []P = p_list.copy()r = len(p_list)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">20923</span>): <span class="hljs-comment">#2020/09/23</span>t = i/<span class="hljs-number">20923</span>x, y = de_Casteljau(r, P, t)result.append((x, y))<span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">de_Casteljau</span>(<span class="hljs-params">n, pointSet_p, t</span>):</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">:param n: number of control</span><span class="hljs-string">:param pointSet_p: (list of list of int:[[x0, y0], [x1, y1], ...])point set of p</span><span class="hljs-string">:param t: t</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">while</span>(n):<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>):P[i][<span class="hljs-number">0</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">0</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]P[i][<span class="hljs-number">1</span>] = (<span class="hljs-number">1</span>-t)*P[i][<span class="hljs-number">1</span>] + t*P[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]n -= <span class="hljs-number">1</span>P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>)P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = int(P[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>)<span class="hljs-keyword">return</span> P[<span class="hljs-number">0</span>]</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>施法中.Bézier基函数的导出[J].航空学报,1980,第1期：P92-98<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八皇后问题</title>
    <link href="/2020/09/24/Eight-Queens/"/>
    <url>/2020/09/24/Eight-Queens/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><p><strong>输入格式</strong><br>一行一个正整数n，表示棋盘是n*n大小的</p><p><strong>输出格式</strong><br>有多少种摆法</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>深搜、标记以及回溯</p><h2 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h2><p>介绍顺序：标记-&gt;深搜-&gt;回溯</p><h4 id="1-标记"><a href="#1-标记" class="headerlink" title="1.标记"></a>1.标记</h4><p> 使用数组记录无法下棋的部分：</p><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>];</code></pre><p>当置为1时，即为无法再放置的标记，具体标记内容：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记j列不能再放置</span>flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线 </span>flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">//标记对角线</span></code></pre><p>举个例子，当棋盘为4*4时：</p><pre><code class="hljs cpp">flag[<span class="hljs-number">2</span>][i+j]=<span class="hljs-number">1</span><span class="hljs-comment">// i=2,j=3；显见在红线处都应该设为1</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ij.jpg" alt=""></p><pre><code class="hljs cpp">flag[<span class="hljs-number">3</span>][i-j+n]=<span class="hljs-number">1</span> <span class="hljs-comment">// i=2,j=3；显见在红线处应都无法放置</span></code></pre><p><img src="/img/blog_contents/Eight_Queens/ijn.jpg" alt=""></p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> res; <span class="hljs-keyword">bool</span> flag[<span class="hljs-number">4</span>][<span class="hljs-number">100</span>]; <span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span> (i &gt; n) &#123;res++;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> ((flag[<span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">2</span>][i + j] == <span class="hljs-number">0</span>) &amp;&amp; (flag[<span class="hljs-number">3</span>][i - j + n] == <span class="hljs-number">0</span>)) &#123;flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记</span>dfs(i + <span class="hljs-number">1</span>);flag[<span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">2</span>][i + j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>flag[<span class="hljs-number">3</span>][i - j + n] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n;dfs(<span class="hljs-number">1</span>);<span class="hljs-built_in">cout</span> &lt;&lt; res;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
